<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-08-08 Tue 18:31 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Haskell</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel='stylesheet' type='text/css' href='/css/main.css'/>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Haskell</h1>
</header><p>
We do not have to do <i>a good third</i> of what Dijekstra did <i>by hand</i> with his <i>imperative</i> code - the compiler will guarantee the absense of simple bugs (which no <i>tests</i> could do). Althrough no compiler could ever prove <i>correctness</i>.
</p>

<p>
We also do not have to consider the <i>imperative aspects</i> of a hardware-based model. We just do <i>pure calculus</i> in Haskell.
</p>

<p>
A big step ahead from Ladrin and Dijekstra.
</p>

<div id="outline-container-org7cfee0c" class="outline-2">
<h2 id="org7cfee0c">Why</h2>
<div class="outline-text-2" id="text-org7cfee0c">
<p>
Because it is, surprise! the most <i>pragmatic</i> language for high-level,
domains,  modeled using mathematics.
</p>

<p>
The really big idea, which has been popularized by Laslie Lamport, is
that one has to model (specify) aspects of ones&rsquo;s domain in pure math,
which then could be mechanically checked for correctness (lack of
contradictions).
</p>

<p>
We need just Sets (the notion of such that) and First Order logic from
 math,  discarding the assumption that <i>False implies anything</i>.
</p>

<p>
We need <i>variable bindings</i>, conditional expressions, and
the <i>function abstraction</i>, of course. This is, basically, what TLA
syntax is.
</p>

<p>
However, math is <i>untyped</i>, or, at best, weakly typed using sets or abstract
structures, such as <i>fields</i>, <i>rings</i> and so on, in other words it is
<i>structually typed</i>.
</p>

<p>
One could use specialized languages with has a build-in prof-checker,
such as <code>coq</code> or <code>Agda</code>, and sometimes it may be reasonable, but one has
to rewrite the solution in an &ldquo;implementation language&rdquo;.
</p>

<p>
Haskell is a pragmatic choice because once the solution compiles and
runs it can be used in production, but this is not the main point. The
crucial thing is that the code is <i>pure</i> (as pure mathematics) and could
be evaluated with a pen and paper using substitution model, just like
math.
</p>

<p>
<i>Equational reasoning</i> enables one to write simple (but actual, valid)
<i>proofs</i> about functions on domain-driven types and even <i>synthetize</i>
some <i>code</i> from <i>proofs</i>.
</p>

<p>
There is no need for another specialized language, because Haskell
technically is a <i>pure logic</i> expressed as highly <i>syntactically sugared</i>
and <i>well-typed</i> polymorphic Lambda Calculus  (System F Omega), augmented with
standard <i>machine types</i> (such as <code>Int</code>, <code>Char</code> or <code>Bool</code>).
</p>

<p>
<i>Algebraic types</i> and <i>universal pattern-matching</i> makes actual boring
programming fun again.
</p>
</div>
</div>
<div id="outline-container-org3017f31" class="outline-2">
<h2 id="org3017f31">Math</h2>
<div class="outline-text-2" id="text-org3017f31">
<p>
The worst code, second only to J2EE, is when amateurs without any
mathematical background are writing Haskell. They are trying to write
the same imperative crap they used to write in Java or PHP, but in
Haskell, so it become J2EE spaghetti with Monads everywhere. After no
one could read or understand it, of course.
</p>

<p>
The way of writing decent Haskell is the same way as writing
mathematics.
</p>

<p>
Haskell is <i>declarative</i> by its nature, in the first place, so one always
writes <i>what is</i> (types) and what to be done <i>eventually</i>, just like a
damn long single conditional expression (actually - a <i>state machine</i>).
</p>

<p>
Yes, one writes a description of a state-machine (an expression which
<code>main</code> returns) to be executed by the <i>runtime</i>, in a pure math (well,
polymorphic lamda calculus).
</p>

<p>
Another <i>plague</i> are unnecessary, redundant abstractions which virtue
signaling amateurs write to show off their presumed smartness.
</p>

<p>
Richard Bird spent decades perfecting his style, which is basically
<i>point-free</i> function composition, <i>pattern-matching</i> and <i>algebraic
data types</i> (which include <i>variants</i> and <i>records</i>), which, as you
might have realized, is the very essence of everything.
</p>

<p>
Haskell has to be written in the Bird style. But most of current coders
have no idea what it is and why it is so special.
</p>

<p>
Most of Haskell projects ended up as an unreadable spaghetti of
imperative crap expressed in a pure functional language with strictness
&ldquo;optimizations&rdquo; and unnecessary, redundant abstractions everywhere.
.
</p>
</div>
</div>
<div id="outline-container-org2a2889b" class="outline-2">
<h2 id="org2a2889b">Pure functional</h2>
<div class="outline-text-2" id="text-org2a2889b">
<p>
The result of any function call is <i>fully determined</i> by its argument.
Same input - same output. Always.
</p>

<p>
Technically, every function has exactly one argument and <i>currying</i>
(nesting of <i>closures</i> which capture their arguments) is used to construct
multi-argument functions. <i>Partial application</i> naturally follows.
</p>

<p>
Like in mathematics, <i>any function call can be replaced by the result of
a previous call with the same parameters</i>. This property is called
the <i>referential transparency</i> principle and is at the core of pure
mathematics - substituting a value for an expression to which it
<i>reduces</i> to.
</p>

<p>
<i>Equational reasoning</i> follows, based on the premise that two <i>expressions</i>
at each side of the <i>equal sing</i> are indeed equal, and can be
<i>substituted for one another</i> (substitution of <i>lets</i> and <i>lambdas</i> employs
distinct special rules).
</p>

<p>
Those principles are used by the compiler, which re-arranges and
 re-writes expressions without breaking their semantics - pure
 mathematical transformations (which, in theory, can be done with a pen
 and paper).
</p>

<p>
These properties are common for any pure-functional subset of a
<i>mostly-functional</i> language, such as Standard ML, or Ocaml, or Erlang
or Scala.
</p>

<p>
Haskell is special in that it uses the <i>call-by-need</i> evaluation strategy
(or a <i>Normal Order</i> of evaluation, as intended by God. Or, at least, by
<i>Church</i>). The original <i>Lambda Calculus</i> and most of <i>systems of logic</i>
use same strategy for application of a set of rules for <i>reductions</i>.
</p>

<p>
Remarkably, Haskell uses the <i>System F Omega</i> under the hood as compiler&rsquo;s
<i>intermediate representation or IR</i>, so, technically, <i>it is a pure
logic</i> until compilation of <code>main</code> ends and execution by the runtime
begins.
</p>

<p>
This means, among other things, that only so-called &ldquo;Domain logic&rdquo; or
<i>domain-driven core types</i> should be implemented in Haskell (and it is
indeed the best possible choice - to define your <i>domain</i> in pure logic)
and everything else should be <i>degelgated</i> to the system by FFI&rsquo;ing or
using calls to an OS.
</p>

<p>
Otherwise one will end up with something like Eterprise Java (J2EE) with
Monads and unnecessary, redundant abstractions based on esoteric stuff,
which is what we already have.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-08-08 Tue 18:31</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.50 (<a href="https://orgmode.org">Org</a> mode 9.7-pre)</p>
</div>
</body>
</html>