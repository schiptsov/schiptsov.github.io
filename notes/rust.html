<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-01-16 Mon 12:38 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Rust</h1>
</header><p>
How to make <code>Rust</code> a realy decent language.
</p>

<ul class="org-ul">
<li>everything is immutable by default, explicitly annotate everything mutable.</li>
<li><code>mut</code> keyword for mutable things</li>
<li><code>:=</code> for imperative assignment (should be rare)</li>
<li><code>=</code> to do universal <i>pattern-matching</i> and variable <i>binding</i></li>
<li>support for <i>Algebraic types</i>, especially proper <i>sum-types</i> and GADTs</li>
<li>Capitalized data-constructors, <i>type inference</i> for <i>Algebraic types</i>.</li>
<li><i>pattern-matching</i> on data-constructors <i>everywhere</i></li>
<li>multi-clause functions (a <i>set of partial functions</i>)</li>
<li><i>type-classes</i> from Haskell (proper set-like <i>relations on interfaces</i>)</li>
<li>just copy Ocaml module system (with more uniform syntax).</li>
</ul>

<p>
Notice that <i>type-classes</i> solve the <i>specification problem</i>, providing more
structured approach (the <i>set-subset</i> relation) than a bunch of
<i>assertions</i> (as in CLU).
</p>

<p>
Literally all languages should use them and Ocaml modules, which is the
same fundamental structuring mechanisms (set-subset + application) at a higher level.
</p>

<p>
Anyway, just move from C++-sh imperative crap to Ocaml&rsquo;s and Scala&rsquo;s
syntactic forms, keeping all the imperative crap as a subset.
</p>

<p>
Mutable, imperative subset should be a more verbose explicit DSL, not a whole of language.
</p>

<p>
In brief, take every high-level feature form decent languages, like
<code>Ocaml</code> or <code>Scala 3</code> without breaking too much. Just like Python or Scala 2 to 3 migration.
</p>

<p>
Again, there are enormous fundamental benefits of having pure-functional
defaults and explicitly annotated imperative features as a subset.
</p>

<p>
Scheme with just <code>(set! ...)</code> syntactic form was the true enlightenment.
Decades of <code>ML</code> and <code>Ocaml</code> (and recently <code>Scala 3</code>) also converged to the same principles.
</p>

<p>
A <i>mostly-functional</i> language with imperative features it the way. Bell
labs successfully researched use of <code>Standard ML</code> as a <i>system language</i>,
but, of course, zoomers never heard of this.
</p>

<p>
<code>Common Lisp</code> was also a <i>system language</i>, which proves that being
<i>high-level</i> is OK.
</p>

<p>
Actually, there, probably, no way of fixing Rust. It is better to start
a new <code>F#</code> and <code>Scala</code>-based language, minimal, clean, principle-guided, like
<code>Scheme</code> used to be. And just like Haskell or Ocaml or F# have proven -
<i>syntax matters /a lot</i>.
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-01-16 Mon 12:38</p>
</div>
</body>
</html>