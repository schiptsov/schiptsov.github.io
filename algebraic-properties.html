<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-04-02 Sun 07:30 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Where the Algebraic properties come from</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Where the Algebraic properties come from</h1>
</header><p>
<i>Why</i> addition and multiplication (as repeated addition) are commutative and subtraction and division is not?
</p>

<p>
<i>Why</i> multiplication (as a repeated addition) distributes over addition?
</p>

<p>
Because, <i>surprise</i>, addition is a captured (by the mind of an external observer) abstract notion of <i>putting or morphing together</i>. It has been  generalized and abstracted out as a <i>binary operation</i>, and when two things come together it is immaterial which one comes &ldquo;first&rdquo; - the result, whatever it is, will be the same. There is no notion of &ldquo;first&rdquo; and &ldquo;second&rdquo;. These are only in the mind of an external observer. 
</p>

<p>
The tradition says that the Buddha proclaimed the fundamenal principle that whatever is <i>compound</i> (being put together) is <i>impermanent</i> and will eventually fall apart. This is true for the Universe outside of our heads (actually our heads are just processes in it), but the other people have created <i>abstract concepts</i> which, they claim, are <i>absolute</i>, <i>ideal</i> and <i>eternal</i> (what a bullshit, lmao!).
</p>

<p>
There is, however, a &ldquo;higher precedence&rdquo; of what we call &ldquo;reality&rdquo; over any abstract concepts of the Mind, and every <i>fundamental</i> concept could, in principle, be traced back to the actual repeated pattern (caused by a particular phenomena) <i>it has been generalized from</i>. At least this is how our minds emerged from the evolution - we just create, maintain and <i>use</i> &ldquo;grossly oversimplified (and hence useful!) maps&rdquo; of the shared environment inside our heads.
</p>

<p>
So, why the basic algebraic properties are as they are?
</p>

<p>
Putting together two things is <i>relative</i>, which means that which one is added to which is, literally, a matter of a point of view. Rotate the observer around the observed locality, and it is the other way around. <i>This</i> (and only this) is what behind <i>commutativity of addition</i>.
</p>

<p>
In our evolved spoken language we say 2 <i>and</i> 2, for referring to a process of putting tougher, and we say 2 times 2 to indicate how many <i>times</i> we add (to itself). These are results of a <i>intuitive capture and a proper generalization</i>.
</p>

<p>
The problem with a language, as every mathematician knows, is that it is ambiguous and the names we use are grossly <i>over-loaded</i> and only seem to mean (refer to) the same &ldquo;thing&rdquo; (concept).
</p>

<p>
Multiplication of Naturals (which is indeed a <i>repeated addition</i>) is not the same as multiplication of Reals or by a Real Number (which is <i>scaling</i>). Very clever people &ldquo;disentangled&rdquo; and <i>partitioned</i> the mess into individual <i>algebraic systems</i>, by explicitly declaring which Set and which operations we may use. Then they have classified such algebraic system and observed some commonalities.
</p>

<p>
We use <i>very</i> clever tricks to create a full <i>Numeric Tower</i> by casting <i>Numbers</i> between <i>Number Systems</i> (crossing an abstraction barrier, literally) but there is <i>nothing</i> in the Universe that corresponds to our mental tricks. Mother Nature does not even count. 
</p>

<p>
So the most universal, fundamental and general recurring <i>pattern</i> we have captured and generalized is <i>putting together</i> as <i>addition</i>. The properties of addition are &ldquo;universal&rdquo;, up to and including <i>associativity</i>. Then is becomes too abstract for this Universe.
</p>

<p>
Where that associativity comes from? The <i>binary operation</i> has to produce the result of exactly the same kind as its argument. As long as it does, the order of composition is immaterial. Some people would say that this <i>Closure property</i> is the most fundamental about the Number abstractions.
</p>

<p>
Notice that in the Universe this property is very <i>rare</i>, because addition or &ldquo;composition&rdquo; usually produces structurally different results, which means a different kind of outcome, which we may call <i>crossing an abstraction barrier</i>.
</p>

<p>
No surprise that subtraction and division may cross the abstraction barriers of our Number Systems, so they are not proper <i>operations</i> of an algebraic system.
</p>

<p>
Function composition is actually <i>concatenation</i> (pipe-lining) so it <i>is</i> associative (it does not matter which parts of a pipe one connects first) &#x2013; the result will be the same. So, is DNA synthesis (actual assembling of a chromosome) is forms a Semigroup?
</p>

<p>
The further we get, by adding the abstract notion of an <i>identity</i> element (<i>zero</i> for addition), the further we wander away from What Is deeper in the real of what we <i>think</i> there Is. Mother Nature has no <i>no-ops</i> of any kind, it either &ldquo;clicks&rdquo; or not.
</p>

<p>
Our <i>Monoids</i> are already a gross over-generalization - they occur only in the realm of too abstract Numbers and <i>nowhere else</i>. There are reasons why people of the past refused to accept negative Numbers, or Irrational Numbers, leave alone Imaginary Numbers. All numbers are imaginary in the first place. We enrich and refine our abstract systems, but the instances of them are nowhere to be found. 
</p>

<p>
It seems that <i>Semigroups</i> is how far we can stretch, because it captures <i>concatenation</i>, which is a particular way of <i>putting together</i>. We have something like this at a molecular level.
</p>

<p>
<i>Groups</i> are even further away, even if they are useful and seemingly capture lots of <i>abstract patterns</i>, like <i>rotations</i> and certain <i>symmetries</i>. The notion of a Group captures the commonalities of some of our artificial abstractions, just like introspection captures our feelings. These Groups, however, are only (and only) our <i>shared (in the culture) mental constructs</i>, even if the generalizations are <i>valid</i> (properly captured).
</p>

<p>
Capturing, generalizing, abstracting out and using such precisely-defined abstraction is what Mathematics is (notice the lack of &ldquo;about&rdquo;). 
</p>

<p>
One more time. <i>Groups</i> do not occur or exist anywhere. The definitive <i>mantra</i> of all mathematics is that <i>&ldquo;existence does not required&rdquo;</i>.
</p>

<p>
The point is to understand once and for all, that the <i>systems</i> (a Set with an at least one <i>operation</i>) are mental constructs. The <i>abstract structures</i> they seemingly capture are <i>forms or shapes of created by the Mind abstractions</i>. Nothing wrong with that.
</p>

<p>
The ability to show and <i>prove</i> that two abstract algebraic systems <i>have the same abstract structure</i> (are <i>isomorphic</i> to each other) is quite remarkable, but this is just the precise way of saying that &ldquo;airplanes look a lot like birds - have almost the same shape&rdquo;. A lot can be generalized from pictures of <i>arrows between dots</i> with just a few basic notions - <i>direction</i>, <i>counting</i>, <i>links between two dots</i>, and <i>concatenation</i>. 
</p>

<p>
Even the <i>Number Theory</i> could be &ldquo;put down to earth&rdquo; just by observing (at another, social level) that it too is socially constructed, and is based on the ability to &ldquo;see&rdquo; and define abstract patterns, which require a <i>particular social conditioning</i>.
</p>

<p>
<i>Prime-ness</i>, by the way, is just this property of <i>not</i> being a result of a <i>repeated addition to itself</i> of <i>any</i> other number. It is <i>not</i> a <i>product</i>, so to speak. A <i>pile</i> of this size cannot be taken apart into any number of equal piles without something left over (a reminder).
</p>

<p>
This is, indeed, a <i>universal property</i> because it has been properly generalized from recurring patterns which actually occur (just as Natural Numbers themselves), but it has no deeper consequences that <i>cannot be taken into any number of <b>equal</b> parts</i>.
</p>

<p>
There is no one, except an <i>external observer</i>, to <i>use</i> this property, and only by the virtue of being an observer this property has been captured. This is just an <i>accident</i> of the Universe - well, some piles cannot be taken apart into any number of equal piles, so what?.
</p>

<p>
The formal reasoning about this observed property is, of course, quite remarkable and is a hallmark of our mental abilities of manipulating abstract symbols. Our ability to <i>use</i> prime numbers <i>in our complex abstractions</i> is, of course, a miracle, but this is a different story.
</p>

<p>
Yes, we are able to generalize and abstract out, and even produce <i>machines</i> to manipulate our abstractions, and build complex abstractions (out of simpler ones) inside our minds, and then represent and <i>implement</i> some inside our machines. Notice, however, that our machines has been build upon very few, most fundamental, carefully selected <i>properly captured, universal abstractions</i> and nothing else.
</p>

<p>
The problem is that <i>some, even most</i> of out complex abstractions <i>have no correspondence with (no arrow back to) reality</i>, while we have convinced ourselves (by unverified socially constructed arguments) that they really do. Do you see the <i>veil</i>?
</p>

<p>
Taking apart, it is said, to the opposite of putting together. But it seems that in the Universe what has been put together is not &ldquo;supposed&rdquo; to be taken apart. It will, eventually, due to entropy, but it forms are tend to be &ldquo;stable&rdquo; long enough to become <i>building blocks</i>.
</p>

<p>
Why subtraction is not commutative? Because we have generalized too much. Taking apart of only (exactly) what previously has been put together (as it usually happens in the universe and in Lego) would have no such problem. It does not matter &ldquo;at which side you pull&rdquo;.
</p>

<p>
Lets use an evolved spoken human language. What is <i>an one-half of an one-half</i>? Well, it is one-forth? Which half is which? Does not matter. <i>Why</i> it does not matter? Because a the rule says <i>multiply the denominators</i>, which are always <i>Naturals</i>, and multiplication of Naturals is a repeated addition?
</p>

<p>
<i>Why</i> 3 times 2 is the same as 2 times 3? Because it does not mater which one is being added to itself the other <i>times</i>, and this corresponds to the notion of an area of a rectangle, which is, of course, a universal one.
</p>

<p>
What is one-half of one-forth? It is one-eight. But <i>why</i> is one-forth of one-half is also one-eight? Because there is a rectangle of denominators under the hood?.
</p>

<p>
Notice, that we do not naturally say <i>times</i>, we say <i>of</i>. This is a different kind of multiplication, it just so happens that the <i>rule</i> uses that other notion of <i>times</i>.
</p>

<p>
And indeed with reciprocals (special case of fractions) we divide by multiplying. Or is it something else? 
</p>

<div id="outline-container-org945f1c8" class="outline-2">
<h2 id="org945f1c8">How do we program?</h2>
<div class="outline-text-2" id="text-org945f1c8">
<p>
Well, first we try to <i>capture</i> &ldquo;just right&rdquo; abstractions in terms of Sets, First-Order Logic and Algebraic Data Types. These are still in the realm of pure mathematics.
</p>

<p>
Then we look to see if our abstractions have the <i>shape</i> of some &ldquo;standard&rdquo; type-classes. Usually, <code>Semigroup</code>, <code>Functor</code> or <code>Monoid</code>. For data types we usually want <code>Traversable</code> and/or <code>Foldable</code>. We may have some <code>Applicatives</code>, but actually it is a &ldquo;warning sign&rdquo; of <i>over-abstraction</i>.
</p>

<p>
We want to have a <code>Monad</code> for various reasons, but never for the sake of merely abstraction. Monads are necessary for defining <i>abstraction barriers</i> and <i>to compose</i> as we compose ordinary functions (it will be <i>nesting of lambdas</i> under the hood).
</p>

<p>
It is of the second importance that they are (instances of) <code>Monoids</code> and <code>Applicatives</code> and <code>Functors</code>. Usually we need just one aspect or another.
</p>

<p>
Once we define our abstract structures (from the problem domain) we <i>implement</i> them in Haskell or Scala 3. Just like with underlying mathematics, everything must be immutable.
</p>

<p>
Haskell is much more preferable due to the operational properties of <i>evaluation using graph reduction</i>. This is as if one evaluates with a pen and paper - completely secure. It is even on another, much higher realm from an imperative sequential machine code. The &ldquo;security&rdquo; is absolute and total.
</p>

<p>
Scala 3 is also good as long as one stays in its pure functional subset and build-up lazy expressions to be evaluated by an embedded interpreter. This is how advanced libraries ought to be build - as layers of DSLs.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-04-02 Sun 07:30</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.0.60 (<a href="https://orgmode.org">Org</a> mode 9.6.1)</p>
</div>
</body>
</html>