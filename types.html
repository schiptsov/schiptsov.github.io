<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-10-01 Sat 18:55 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Types</title>
  <meta name="author" content="&lt;schiptsov@gmail.com&gt;">
  <meta name="description" content=
  "Types for a Functional Programmer">
  <meta name="generator" content="Org Mode">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css?family=Fira Sans"
  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira Code"
  rel="stylesheet">
  <link rel='stylesheet' type='text/css' href='/css/main.css'>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "left",
               TagIndent: ".8em"
             }
  });
  </script>
  <script src=
  "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js?config=TeX-AMS_HTML"></script>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Types</h1>
    </header>
    <div id="outline-container-org9284ff7" class="outline-2">
      <h2 id="org9284ff7">Cardinality of a type</h2>
      <div class="outline-text-2" id="text-org9284ff7">
        <p>Cardinality (the size) is the only <i>structural
        (general) property</i> of a Set.</p>
        <p>Associate a type with cardinality (just like of a Set)
        How many inhabitants (members) a type has. Ignore bottoms
        (they are relevant only in type-constraint solving)</p>
        <div class="org-src-container">
          <pre class="src src-haskell"><span style=
          "color: #81A1C1;">data</span> <span style=
          "color: #8FBCBB;">Void</span> <span style=
          "color: #6f7787;">-- </span><span style=
          "color: #6f7787;">0, no elements, just like The Empty Set</span>

<span style="color: #81A1C1;">data</span> <span style=
"color: #81A1C1;">()</span> <span style=
"color: #D8DEE9;">=</span> <span style=
"color: #81A1C1;">()</span> <span style=
"color: #6f7787;">-- </span><span style=
"color: #6f7787;">exactly 1, exactly this - no new information</span>

<span style="color: #81A1C1;">data</span> <span style=
"color: #8FBCBB;">Bool</span> <span style=
"color: #D8DEE9;">=</span> <span style=
"color: #8FBCBB;">True</span> <span style=
"color: #D8DEE9;">|</span> <span style=
"color: #8FBCBB;">False</span> <span style=
"color: #6f7787;">-- </span><span style=
"color: #6f7787;">just these 2. notice the |</span>

<span style="color: #81A1C1;">data</span> <span style=
"color: #81A1C1;">(</span><span style=
"color: #8FBCBB;">,</span><span style=
"color: #81A1C1;">)</span> a b <span style=
"color: #D8DEE9;">=</span> <span style=
"color: #81A1C1;">(</span><span style=
"color: #8FBCBB;">,</span><span style=
"color: #81A1C1;">)</span> a b <span style=
"color: #6f7787;">-- </span><span style=
"color: #6f7787;">a type-constructor, parametrized by a nd b</span>
</pre>
        </div>
      </div>
      <div id="outline-container-orgb8dd07d" class="outline-3">
        <h3 id="orgb8dd07d">Shapes or forms</h3>
        <div class="outline-text-3" id="text-orgb8dd07d">
          <p>Notice that these types have distinct, unique
          <i>shapes</i></p>
          <ul class="org-ul">
            <li><code>|</code> stands for an <i>alternative or a
            possibility</i> - <code>OR ELSE</code> (a “fork” -
            <i>this or that</i>).</li>
            <li><code>,</code> stands for <code>AND ALSO</code>
            (pretense in the same locality) (a “join” - <i>this and
            that</i>).</li>
          </ul>
          <p>Notice that</p>
          <ul class="org-ul">
            <li>only one “branch” of a “fork” can be taken
            (<i>observed</i>).</li>
            <li>an <i>aggregate</i> (a compound) is fundamentally
            different (has its own <i>unique /properties</i>) from
            its individual parts.</li>
          </ul>
        </div>
      </div>
    </div>
    <div id="outline-container-org10cdef3" class="outline-2">
      <h2 id="org10cdef3">Total</h2>
      <div class="outline-text-2" id="text-org10cdef3">
        <p>Knowing cardinalities of any two types (sets) we can
        know how many “arrows” (distinct relations or individual
        mappings) are there <i>in total</i>.</p>
        <p>When we try to <i>visualize</i> (or formally define as a
        directed graph) the totality of all the possible relations
        we will notice that the resulting shapes (abstract
        structures) are the same (same number, same direction).</p>
        <p>And this is it. This does not imply anything more than
        that - just similarity in its totality - a purely abstract
        notion.</p>
        <p>The notion of duality based on cardinality alone is
        wrong and misleading.</p>
      </div>
    </div>
    <div id="outline-container-orgc05a012" class="outline-2">
      <h2 id="orgc05a012">Isomorphism</h2>
      <div class="outline-text-2" id="text-orgc05a012">
        <p>Any two types of the same cardinality could be viewed as
        <i>isomorphic</i>. This is a naive and too abstract to be
        useful assumption.</p>
        <p>The <i>shape</i> (the <i>form</i> or <i>structure</i>)
        of the type is its distinct feature, out of which its
        <i>properties</i> arise (just as it is with molecules).</p>
        <p>A “fork” is not isomorphic to a “join” in principle, but
        these are viewed by some sectarians as such.</p>
      </div>
      <div id="outline-container-org96e9068" class="outline-3">
        <h3 id="org96e9068">Definition</h3>
        <div class="outline-text-3" id="text-org96e9068">
          <p>The formal definition is this</p>
          <ul class="org-ul">
            <li><i>there is a pair of total functions between two
            types (sets)</i></li>
            <li>any <i>composition of these two functions is an
            identity (a round trip)</i></li>
          </ul>
          <p>When two types (sets) has the same cardinality, an
          <i>one-to-one correspondence</i> (a mapping between whole
          types) could be defined <i>in principle</i> as a pair of
          total functions (on whole types).</p>
        </div>
      </div>
      <div id="outline-container-orga79f6b4" class="outline-3">
        <h3 id="orga79f6b4">Ordering</h3>
        <div class="outline-text-3" id="text-orga79f6b4">
          <p>As long as cardinality is greater than 1 a particular
          <i>ordering</i> has to be defined (become a part of an
          abstract mathematical structure).</p>
        </div>
      </div>
      <div id="outline-container-org6857be5" class="outline-3">
        <h3 id="org6857be5">An ordered set of arrows</h3>
        <div class="outline-text-3" id="text-org6857be5">
          <p>Individual “arrows” (relations) <i>between values</i>
          has to be in a particular order.</p>
          <p>Each “arrow” has to have a unique <i>inverse</i>
          “arrow” (which goes back where it started).</p>
          <p>The meaning and validity of such functions does not
          concern mathematicians (only good philosophers).</p>
          <p>Symmetries (rotations) could be formalized with such
          sets of functions.</p>
        </div>
      </div>
      <div id="outline-container-org7a417c9" class="outline-3">
        <h3 id="org7a417c9">n!</h3>
        <div class="outline-text-3" id="text-org7a417c9">
          <p>For any two types (sets) of the same cardinality \(n\)
          there are \(n!\) <i>unique</i> isomorphisms between
          them.</p>
        </div>
      </div>
      <div id="outline-container-org9ed79ed" class="outline-3">
        <h3 id="org9ed79ed">Same cardinality does not imply the
        same shape</h3>
        <div class="outline-text-3" id="text-org9ed79ed">
          <p><i>Knowing that an isomorphism exists is enough. An
          isomorphism between types \(s\) and \(t\) is a proof that
          /for all intents and purposes</i>, \(s\) and \(t\) are
          the same thing/.</p>
          <p>This, of course, is bullshit.</p>
        </div>
      </div>
      <div id="outline-container-orgfd38286" class="outline-3">
        <h3 id="orgfd38286">The laws</h3>
        <div class="outline-text-3" id="text-orgfd38286">
          <p>The cardinality of a <i>sum-type</i> is the sum of the
          cardinalities of its constructors.</p>
          <p>The cardinality of a <i>product-type</i> is the
          product of cardinalities of its parts.</p>
          <p>It is said that these are <i>duals</i>, which is,
          again, bullshit.</p>
          <p>The <i>sum-</i> and <i>product-</i> types have
          different <i>shapes</i> or <i>forms</i>.</p>
        </div>
      </div>
      <div id="outline-container-orga434ecd" class="outline-3">
        <h3 id="orga434ecd">Monoidial identities</h3>
        <div class="outline-text-3" id="text-orga434ecd">
          <p><code>()</code> is a Monoidal Identity element for
          product-types (no new information). <code>Void</code> is
          an identity element for sum-types (<code>Void</code> has
          no members).</p>
        </div>
      </div>
    </div>
    <div id="outline-container-orgda43bd9" class="outline-2">
      <h2 id="orgda43bd9">Exponentials</h2>
      <div class="outline-text-2" id="text-orgda43bd9">
        <p>The type \(A \rightarrow B\) has cardinality \(B^{A}\)
        .</p>
        <p>For every value of \(a\) in the <i>domain</i>, there is
        a \(b\) in \(B\). We can chose <i>any value</i> of \(B\)
        for every value in \(A\) so it is \(b \times b \times \dots
        \times b\) exactly \(a\) times.</p>
      </div>
    </div>
    <div id="outline-container-org8e5e0f4" class="outline-2">
      <h2 id="org8e5e0f4">Notes</h2>
      <div class="outline-text-2" id="text-org8e5e0f4"></div>
      <div id="outline-container-org5b5a14c" class="outline-3">
        <h3 id="org5b5a14c">Strings</h3>
        <div class="outline-text-3" id="text-org5b5a14c">
          <p>A <i>sequence</i> of elements from the same set (an
          alphabet) is called a <i>String</i> and it is a “natural”
          <i>type</i>. A sequence of words from the same set (a
          shared vocabulary) is another one.</p>
          <p><i>All</i> Strings of length \(n\) denoted as
          \(S^{n}\) are \(S\times S \times S \times ... \times S\)
          taken \(n\) times.</p>
        </div>
      </div>
      <div id="outline-container-org8971f4b" class="outline-3">
        <h3 id="org8971f4b">Algebraic types</h3>
        <div class="outline-text-3" id="text-org8971f4b">
          <p><code>-&gt;</code> a set of all <i>ordered pairs</i>
          (arrows) - a <i>function space</i> <code>{ , }</code>
          records are <i>labeled</i> Cartesian Products (a
          \(\times\)) <code>{ | }</code> variants are
          <i>labeled</i> Disjoint Unions (an <code>XOR</code>) It
          is said that these two a “structural” <i>dual</i> to each
          other (all arrows being flipped).</p>
          <p>Labeled means <i>name-based selection</i> (unordered
          in theory). There is always some particular order in an
          actual implementation.</p>
        </div>
      </div>
      <div id="outline-container-orgea46991" class="outline-3">
        <h3 id="orgea46991">Type-classes</h3>
        <div class="outline-text-3" id="text-orgea46991">
          <p><code>Num a =&gt; [a] -&gt; a</code> This type states
          that for any <i>type <code>a</code> of Numbers</i>, sum
          is a function that <i>maps a list of such numbers to a
          single such number</i>.</p>
        </div>
      </div>
      <div id="outline-container-org9eadcf3" class="outline-3">
        <h3 id="org9eadcf3">Nesting</h3>
        <div class="outline-text-3" id="text-org9eadcf3">
          <p>When we think of “structured values” we imply
          <i>nesting</i> of types.</p>
          <p>Algebraic types can be nested, just as
          expressions.</p>
        </div>
      </div>
      <div id="outline-container-orgc7d5cac" class="outline-3">
        <h3 id="orgc7d5cac">Interfaces</h3>
        <div class="outline-text-3" id="text-orgc7d5cac">
          <p>Interfaces are as fundamental as cell membranes - they
          establish penetrable partitions.</p>
        </div>
      </div>
      <div id="outline-container-org0d3c13c" class="outline-3">
        <h3 id="org0d3c13c">Polymorphism</h3>
        <div class="outline-text-3" id="text-org0d3c13c">
          <p>Parametric polymorphism is “on” types with the same
          <i>nested structures</i>. This is, of course, how
          different molecules with same parts can be used.</p>
          <p>Sub-typing polymorphism is “on” types with same
          <i>nested interfaces</i>. This is “duck-typing” and the
          essence of message-passing (what goes in and when).</p>
          <p>In general, abstracting out and formalizing some
          <i>Universal mechanisms</i> (found in reality) is the
          best strategy.</p>
        </div>
      </div>
    </div>
    <div id="outline-container-org5c1152b" class="outline-2">
      <h2 id="org5c1152b">Sets of values</h2>
      <div class="outline-text-2" id="text-org5c1152b">
        <p>Types are based on a formally defined mathematical
        notion of a <code>Set</code>. Types are <i>sets of
        values</i>, defined by sets of <i>constraints</i>
        (corresponding to particual properties).</p>
        <p>An optional <i>set-subset relation</i> for types is
        formally defined using the notion of <i>type-class</i>.</p>
        <p>Constraints on type are of various kinds, most notably -
        <i>structural</i> (when values have a particular structure)
        and those defined by so-called <i>duck-typing</i>, which
        means to have a set of <i>signatures</i> to be implemented
        (<i>to be an</i> <code>X</code> is to exibit such and such
        <i>behaviors</i>), along with <i>additional
        constraints</i>, sometimes called “laws”, formally defined
        elsewhere.</p>
        <p>The <i>set-subset</i> relation is used to
        <i>specialize</i> the resulting types or to define a
        <i>family of types</i>, using the formal notion of a
        <i>type-class</i>.</p>
      </div>
    </div>
    <div id="outline-container-orgaf97484" class="outline-2">
      <h2 id="orgaf97484">Type-classes</h2>
      <div class="outline-text-2" id="text-orgaf97484">
        <p>First of all, a <i>type-class</i> is a <i>higer-level
        abstraction over types</i>, and each particular
        <i>instance</i> of a type-class is <i>type</i>. The
        mathematical analogy is a <i>Set of Sets</i> while members
        (types) have an additional strucure (a set of required
        <i>signatures</i>).</p>
        <p><i>Type-classes</i> are defined by specifying a set of
        <i>function signatures</i> which are required to be
        implemented. Together all the <i>signatures</i> corresponds
        to a <i>module singnature</i> in ML or Ocaml. It is a
        closely related idea, but instead of being a <i>Module</i>
        an type-class is a <i>type-level</i> abstraction.</p>
        <p>A <i>class-constraint</i> is modeled after a
        <i>set-subset relation</i> and implies that all the
        <i>required signatures</i> (for an instance of a particular
        type-class) are <i>already implemented</i> for a type.</p>
        <p>Basically, a type-class defines a <i>family of types</i>
        using a <i>set of required signatures</i> together with an
        <i>optional class-constraint</i>.</p>
        <p>Signatures act as “<i>such that</i>” selectors in
        mathematical logic.</p>
        <p>It can be read as: “a subset of <code>X</code>, <i>such
        that</i> (list of specific constraints)” - which is very
        similar in its nature to <i>declarative list comprehensions
        with generators and boolean guards</i>.</p>
      </div>
    </div>
    <div id="outline-container-orgb5cd14a" class="outline-2">
      <h2 id="orgb5cd14a">Overloaded functions</h2>
      <div class="outline-text-2" id="text-orgb5cd14a">
        <p>This <i>type signature</i> implies that <code>(+)</code>
        is <i>overloaded</i>, which means could be applied to
        different types (provided both aguments are of the same
        type).</p>
        <div class="org-src-container">
          <pre class="src src-haskell"><span style=
          "color: #81A1C1;">(</span><span style=
          "color: #88C0D0;">+</span><span style=
          "color: #81A1C1;">)</span> <span style=
          "color: #D8DEE9;">::</span> <span style=
          "color: #8FBCBB;">Num</span> a <span style=
          "color: #D8DEE9;">=&gt;</span> a <span style=
          "color: #D8DEE9;">-&gt;</span> a <span style=
          "color: #D8DEE9;">-&gt;</span> a
</pre>
        </div>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
    <p class="email">Email: <a href=
    "mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
    <p class="date">Created: 2022-10-01 Sat 18:55</p>
  </div>
</body>
</html>
