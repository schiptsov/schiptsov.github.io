<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-10-22 Sat 18:54 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Principle Guided Development</title>
  <meta name="author" content="schiptsov@gmail.com">
  <meta name="generator" content="Org Mode">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css?family=Fira Sans"
  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira Code"
  rel="stylesheet">
  <link rel='stylesheet' type='text/css' href='/css/main.css'>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Principle Guided Development</h1>
    </header>
    <div id="outline-container-org70c4ef9" class="outline-2">
      <h2 id="org70c4ef9">All you need is Lambda</h2>
      <div class="outline-text-2" id="text-org70c4ef9">
        <p>The Lambda Calculus showed us that <i>abstraction</i>
        and <i>application</i> is enough for everything (but too
        unrestricted - everything could be applied to everything
        else, which is <i>wrong</i>).</p>
      </div>
    </div>
    <div id="outline-container-org8dc9447" class="outline-2">
      <h2 id="org8dc9447">Just 3 shapes.</h2>
      <div class="outline-text-2" id="text-org8dc9447">
        <p>Every algorithm could be expressed as a
        <i>flow-chart</i> with just 3 <i>forms</i></p>
        <ul class="org-ul">
          <li>sequencing</li>
          <li>branching (conditionals, pattern-matching)</li>
          <li>looping (which must be is a recursive call
          really)</li>
        </ul>
      </div>
    </div>
    <div id="outline-container-org5649038" class="outline-2">
      <h2 id="org5649038">Just sums, products and functions</h2>
      <div class="outline-text-2" id="text-org5649038">
        <p>Algebraic data types correspond to so-called abstract
        <i>universal constrictions</i></p>
        <ul class="org-ul">
          <li>a <i>product</i></li>
          <li>a <i>coproduct</i> (or a <i>sum</i>)</li>
          <li>an arrow (a single step or <i>transition</i>)</li>
        </ul>
      </div>
    </div>
    <div id="outline-container-org06e2724" class="outline-2">
      <h2 id="org06e2724">Nesting</h2>
      <div class="outline-text-2" id="text-org06e2724">
        <p>Once you have these universal basic building blocks you
        <i>nest them</i>.</p>
        <p>This is how one gets arbitrary complex, but <i>fully
        specified and well-typed</i> abstract structures.</p>
      </div>
    </div>
    <div id="outline-container-org3d12e5e" class="outline-2">
      <h2 id="org3d12e5e">Composition</h2>
      <div class="outline-text-2" id="text-org3d12e5e">
        <p>The essence of a <i>Monoid</i> is not an identity
        element, but the <i>closure property</i> - that the result
        of the <i>associative binary operation</i> is in the
        <i>same set</i> (of the same type or kind).</p>
        <p>It is due to this property everything <i>composes</i> in
        principle.</p>
        <p>Associativity is also crucial, and an identity is
        required to do it “right” (the base cases).</p>
      </div>
    </div>
    <div id="outline-container-orga5a3967" class="outline-2">
      <h2 id="orga5a3967">Abstraction barriers</h2>
      <div class="outline-text-2" id="text-orga5a3967">
        <p>Abstract interfaces (of ADTs) act as <i>cell
        membranes</i>.</p>
        <p>With them on just puts everything together, like <i>Lego
        blocks</i>.</p>
      </div>
    </div>
    <div id="outline-container-org101cb27" class="outline-2">
      <h2 id="org101cb27">Pattern-matching</h2>
      <div class="outline-text-2" id="text-org101cb27">
        <p>The notion for a <i>nested value</i> of being of
        <i>exactly the same shape</i>.</p>
        <p>Suddenly one has a precise language to talk about
        <i>shapes of values</i>.</p>
      </div>
    </div>
    <div id="outline-container-org6c49c1a" class="outline-2">
      <h2 id="org6c49c1a">Curried functions</h2>
      <div class="outline-text-2" id="text-org6c49c1a">
        <p>Uniformity is a sign of approaching perfection.
        <i>Partial application</i> is essential.</p>
      </div>
    </div>
    <div id="outline-container-orgaa5ddb3" class="outline-2">
      <h2 id="orgaa5ddb3">Parameterized types</h2>
      <div class="outline-text-2" id="text-orgaa5ddb3">
        <p>Type-constructors are just the same notion as
        <i>data-constructors</i>, but at the type-level.</p>
      </div>
    </div>
    <div id="outline-container-org19ad508" class="outline-2">
      <h2 id="org19ad508">Currying at the type level</h2>
      <div class="outline-text-2" id="text-org19ad508">
        <p><i>Partial application of type-constructors</i> is
        useful.</p>
        <p>We still don’t have this in Haskell or Ocaml.
        <code>Scala 3</code> is going in this direction.</p>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: schiptsov@gmail.com</p>
    <p class="email">Email: <a href=
    "mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
    <p class="date">Created: 2022-10-22 Sat 18:54</p>
  </div>
</body>
</html>
