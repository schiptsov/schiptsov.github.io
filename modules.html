<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-05-13 Fri 14:04 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Modules</title>
  <meta name="author" content="&lt;schiptsov@gmail.com&gt;">
  <meta name="description" content=
  "Modules for a Functional Programmer">
  <meta name="generator" content="Org Mode">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css?family=Fira Sans"
  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira Code"
  rel="stylesheet">
  <link rel='stylesheet' type='text/css' href='css/main.css'>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Modules</h1>
    </header>
    <p>Packages (archaic name for modules) allow the definition of
    groups (Sets) of related functions that share a local hidden
    data structure (actual representation) by hiding it (literally)
    within a package body.</p>
    <p>Partitioning and Nesting are the main principles. Types
    should be abstract.</p>
    <div id="outline-container-org2d998a8" class="outline-2">
      <h2 id="org2d998a8">Record</h2>
      <div class="outline-text-2" id="text-org2d998a8">
        <p>Conceptually, a module is <i>an instance of</i> a
        <a href="record.html">record</a> (it is not a
        <i>record-type</i>) of given type-signatures (which is a
        symbol-type pair).</p>
        <p>We cannot say that a module is a <i>Cartesian
        Product</i> of typed slots (<i>type-signatures</i>),
        because they are fixed (are constants) and do not range
        over some Set (like variables).</p>
      </div>
    </div>
    <div id="outline-container-org29e3af0" class="outline-2">
      <h2 id="org29e3af0">Structure</h2>
      <div class="outline-text-2" id="text-org29e3af0">
        <p>So it is an instance - (a single <i>record-value</i>) -
        a particular structure as they called in Standard ML or
        Ocaml or F#.</p>
        <p>The access is similar to <i>selectors</i> for record’s
        slots.</p>
      </div>
    </div>
    <div id="outline-container-orgcb48642" class="outline-2">
      <h2 id="orgcb48642">Signatures</h2>
      <div class="outline-text-2" id="text-orgcb48642">
        <p>Each such “structure” has its own “signature” which
        corresponds to its particular “type”.</p>
        <p>Conceptually, a module-signature is just a Set of
        type-signatures of individual values (which could be
        <i>functions</i>, <i>exceptions</i> or even
        <i>types</i>).</p>
      </div>
    </div>
    <div id="outline-container-org77ff1bf" class="outline-2">
      <h2 id="org77ff1bf">Abstraction barrier</h2>
      <div class="outline-text-2" id="text-org77ff1bf">
        <p>This module-signature, at least in theory, forms an
        actual <i>Abstraction Barrier</i> (which acts like a
        cell-membrane of a module) that hides (encapsulates)
        “concrete” representation and implementation of an Abstract
        Data Type (ideally, at least).</p>
        <p>This analogy with cell biology is deliberate and
        profound. Abstraction barriers (proper message-passing
        interfaces) are cell-membranes between <i>loose-coupled</i>
        modules (and corresponding <i>core types</i>).</p>
      </div>
    </div>
    <div id="outline-container-orgf9112e2" class="outline-2">
      <h2 id="orgf9112e2">Interfaces</h2>
      <div class="outline-text-2" id="text-orgf9112e2">
        <p>Modules <i>export</i> a Set of public (use-side,
        exposed) interfaces (which are, in turn, Sets of individual
        type-signatures).</p>
        <p>These sets of interfaces (module-signatures) can be
        specialized or even applied to one another.</p>
        <p>SML (and Ocaml) got it right. F# too.</p>
      </div>
    </div>
    <div id="outline-container-orgea2eb2d" class="outline-2">
      <h2 id="orgea2eb2d">Modular programming</h2>
      <div class="outline-text-2" id="text-orgea2eb2d">
        <p>The most important principle in whole Computer Science -
        the Molecularity Principle - is about how (and why)
        <a href="ADTs.html">Abstract Data Types</a> should be
        defined.</p>
        <p>One of the fundamental advantages is that an
        <i>underlying representation</i> (and related algorithms)
        could be changed and improved <i>without breaking the
        public interfaces</i>.</p>
        <p>Remember that <i>data dominates</i>. This implies that
        there is no need to recompile the code if it uses dynamic
        (shared) libraries, so the existing system could be
        improved without a re-install.</p>
        <p>This is exactly what pragmatic UNIX systems got right by
        introducing shared libraries.</p>
        <p>And this is precisely what delusional purists advocating
        “reproducible builds” got absolutely wrong. Focus on
        <i>stability of interfaces</i> and you won’t need to hash
        every single build like Haskell tools do.</p>
        <p>Modules are abstractions closely related to ADTs, with
        the core principle of <i>being a separate (independent)
        units of compilation and linking</i>. While <i>intefaces
        establish abstraction barriers which partition and hook
        together</i> the code, modules are about <i>compilation
        units</i>.</p>
        <p>They also solve <i>name clashing</i> (conflict) by
        providing <i>fully qualified</i> symbols (names). When we
        head about “Modular programming” as a paradigm, it implies
        ADTs and Modules with <i>name-spaces</i>.</p>
        <p>Modules are larger scale the building blocks, while the
        ultimate building blocks of any software are
        <i>interfaces</i> and <i>ADTs</i> (which encapsulate actual
        implementations).</p>
        <p>Standard ML (and Ocaml) perfected its module system
        defining modules as having certain <i>structure</i>
        (similar to graphs in mathematics) and providing a DSL for
        <i>application</i> of one module to another (yielding a new
        <i>related</i> structure) similar to what mathematical
        <i>Functors</i> do (they are <i>structure-preserving</i>
        transformations).</p>
        <p>To summarize, modules are about standardized interfaces,
        exactly as ADTs (of which they provide actual data
        representations and implementations), while compilation
        units are of second importance. ML guys got it right,
        others missed the point.</p>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
    <p class="date">Created: 2022-05-13 Fri 14:04</p>
  </div>
</body>
</html>
