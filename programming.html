<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-10-15 Sat 18:42 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Programming</title>
  <meta name="author" content="schiptsov@gmail.com">
  <meta name="generator" content="Org Mode">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css?family=Fira Sans"
  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira Code"
  rel="stylesheet">
  <link rel='stylesheet' type='text/css' href='/css/main.css'>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Programming</h1>
    </header>
    <div id="outline-container-orgb44aa77" class="outline-2">
      <h2 id="orgb44aa77">Just write everything down</h2>
      <div class="outline-text-2" id="text-orgb44aa77">
        <p>The main problem with programming is one being totally
        <i>overwhelmed</i> with irrelevant details, especially in
        <i>C-like imperative languages</i>.</p>
        <p>The solution is the classic <i>layered</i> design, with
        layers of <i>DSLs</i> on top of one another. These DLSa are
        just functions, standardized interfaces and protocols. This
        is how <i>TeX</i> (and <i>LaTeX</i>) has been written and
        other remarkable things like the whole <i>X Window
        System</i>.</p>
        <p>The complexity, however, is still overwhelming. The
        final solution is to write everything down as informal
        specifications, formal specifications and even discrete
        <i>math</i>.</p>
        <p>Informal specs should written be in <i>org-mode</i>,
        formal specs in pure functional languages or even
        specialized theorem provers such as <code>Coq</code> or
        <code>Agda</code> (both have an <i>embedded</i>
        pure-functional language which can be used for a quick
        prototyping).</p>
        <p>Actually, the real problem is that you <i>will forget
        everything you have thought</i>. So it pays to write down
        as much as you can.</p>
        <p>Writing is also the best known from of transmitting a
        knowledge through the time and to other people, including
        to an older you.</p>
        <p>Writing itself is a very challenging and difficult task,
        since an art-level clarity and brevity is required, similar
        to the best mathematical texts which accompany some
        proofs.</p>
      </div>
    </div>
    <div id="outline-container-org734f9d0" class="outline-2">
      <h2 id="org734f9d0">Test Driven Development</h2>
      <div class="outline-text-2" id="text-org734f9d0">
        <p>The consistent practice of writing tests before code is
        a <i>rare non-bullshit advice</i> from the world of project
        management.</p>
        <p>It helps you to focus on a higher-level concepts of
        <i>interfaces</i> (type-signatures) and <i>modules</i> and
        check both the <i>use side</i> and the <i>definition
        side</i>.</p>
        <p><i>ADTs</i> and corresponding <i>modules</i> are at the
        very core of programming (within every <i>paradigm</i>) so
        to beginning with and focus on them is indeed a valuable
        <i>habit</i> to develop.</p>
        <p>Write the tests - your “use side” - before an
        implementation, and check if everything is in accordance
        with your <i>specifications</i>. This is an outline of
        actual design process, insead of day-dreaming and
        hand-waving.</p>
      </div>
    </div>
    <div id="outline-container-org3e3b91e" class="outline-2">
      <h2 id="org3e3b91e">Math</h2>
      <div class="outline-text-2" id="text-org3e3b91e">
        <p>It turns out that before thinking about actual
        interfaces (and type-signatures) even higher-level and mode
        abstract <i>mathematical thinking</i> (and writing) is
        required.</p>
        <p>The two DLSs - of The Set Theory and of the First-Order
        Logic - are at the code of all modern mathematics. Other
        specialized “logics” are occasionally useful.</p>
        <p><i>Always write all the relevant math down</i> (in a
        LaTeX subset of org-mode). This will pay you back
        immensely. First, because you will forget it all in a week.
        Second, because other people can check and even verify your
        reasoning. This is priceless.</p>
      </div>
    </div>
    <div id="outline-container-org089851f" class="outline-2">
      <h2 id="org089851f">UNIX Philosophy + Functional
      Programming</h2>
      <div class="outline-text-2" id="text-org089851f">
        <p>It always looks simple in retrospect. Just take the best
        parts of the UNIX Philosophy (do just one thing but do it
        well, use text streams, files, pipes and sockets) and use
        <code>SML/NJ</code>, <code>Haskell</code> or
        <code>Ocaml</code> instead of <code>C</code> or
        <code>C++</code>. Well, <code>SML</code> is rather a
        monument of the glorious times long gone, so
        <code>Ocaml</code> or <code>Haskell</code> but never
        re-implementing the wheel, and just <i>FFI’ing
        everything</i>.</p>
        <p>If you are trapped in the JVM ecosystem, then there is
        <code>Scala 3</code>, which doing almost everything right,
        except, of course, the fucking dependencines and 3 versions
        of the compiler and standard library in a smallest setup.
        Well, with <code>Haskell</code> that is even worse.</p>
        <p>Text streams and FP maps very well with so-called
        <i>Micro-services architecture</i> - as long as you are
        <i>pure functional</i> (Same input - same output. Always.),
        which implies <i>referentially transparent</i>, you can
        really mix and match “services” just like a functional
        programmer mix and match <i>functions</i>. Yes, for real.
        <code>Coursier</code>, <code>Kafka</code> or <code>Twitter
        toolchain</code> are the actual use cases.</p>
        <p>Just getting rid of imperative code (aliasing problems,
        lifetimes, locks, semaphors, etc) and verbose, boated
        sources is already a bliss and an unexpected return of the
        <i>joy of programming</i> which programmers of the Golden
        Age (Common Lisp, Smalltalk, Standard ML, Miranda, Haskell)
        used to feel. <i>Happy, happy, joy, joy</i> (this is from
        the MIT Scheme).</p>
        <p>Using a <i>high level, mostly functional</i> language in
        UNIX instead of <code>C</code> is (unfortunately) not my
        idea. <i>Bell Labs</i> had a research project which
        resulted in development of the <i>Basis Library</i> and a
        couple of books. Today, it seems that <code>Ocaml</code>
        picked everything up where they left. Just like it was with
        SML, a major <i>theorem proover</i> (<code>Coq</code>) is
        the main project for the whole ecosystem, and it has just
        the <i>standard library</i> in dependencies (well,
        almost).</p>
        <p>Another thing to add is what is loosely called
        <i>reactive programming</i> which is just <i>triggers on
        events from an event stream</i>. This is already a mess and
        a contenst in blog post idiocy, but one could use the right
        abstractions (which are streams and typed events to
        pattern-match upon). Some Haskell’s graphics and animation
        libraries got it right.</p>
        <p>Any kind of immutable databases, ledgers, etc. could
        <i>naturally</i> be developed using this approach.
        <i>Datomic</i> of Rich Hickey is an attempt for an
        <i>immutable store</i>. <i>XTZ</i> is a blockchain
        implementation in pure Ocaml, while others still got stuck
        with <code>C and C++</code>.</p>
        <p>The <i>Haskell Platform</i> (GHC + a small set of
        well-designed libraries) and the <i>Ocaml Ecosystem</i>
        (the compiler, tools and the libraries via
        <code>opam</code>) are <i>production-ready</i>
        environments. One always could enrich them with
        <code>Coq</code>, <code>Agda</code> and <code>TLA+</code>
        to reach the level of an <i>art</i> (instead of that
        <i>learn to code in javascript or python</i> fucking
        abomination).</p>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: schiptsov@gmail.com</p>
    <p class="email">Email: <a href=
    "mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
    <p class="date">Created: 2022-10-15 Sat 18:42</p>
  </div>
</body>
</html>
