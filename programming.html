<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-10-17 Mon 09:45 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Programming</title>
  <meta name="author" content="schiptsov@gmail.com">
  <meta name="generator" content="Org Mode">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css?family=Fira Sans"
  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Fira Code"
  rel="stylesheet">
  <link rel='stylesheet' type='text/css' href='/css/main.css'>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Programming</h1>
    </header>
    <div id="outline-container-orgb44aa77" class="outline-2">
      <h2 id="orgb44aa77">Just write everything down</h2>
      <div class="outline-text-2" id="text-orgb44aa77">
        <p>The main problem with programming is one being totally
        <i>overwhelmed</i> with irrelevant details, especially in
        <i>C-like imperative languages</i>.</p>
        <p>The solution is the classic <i>layered</i> design, with
        layers of <i>DSLs</i> on top of one another. These DLSa are
        just functions, standardized interfaces and protocols. This
        is how <i>TeX</i> (and <i>LaTeX</i>) has been written and
        other remarkable things like the whole <i>X Window
        System</i>.</p>
        <p>The complexity, however, is still overwhelming. The
        final solution is to write everything down as informal
        specifications, formal specifications and even discrete
        <i>math</i>.</p>
        <p>Informal specs should written be in <i>org-mode</i>,
        formal specs in pure functional languages or even
        specialized theorem provers such as <code>Coq</code> or
        <code>Agda</code> (both have an <i>embedded</i>
        pure-functional language which can be used for a quick
        prototyping).</p>
        <p>Actually, the real problem is that you <i>will forget
        everything you have thought</i>. So it pays to write down
        as much as you can.</p>
        <p>Writing is also the best known from of transmitting a
        knowledge through the time and to other people, including
        to an older you.</p>
        <p>Writing itself is a very challenging and difficult task,
        since an art-level clarity and brevity is required, similar
        to the best mathematical texts which accompany some
        proofs.</p>
      </div>
    </div>
    <div id="outline-container-org734f9d0" class="outline-2">
      <h2 id="org734f9d0">Test Driven Development</h2>
      <div class="outline-text-2" id="text-org734f9d0">
        <p>The consistent practice of writing tests before code is
        a <i>rare non-bullshit advice</i> from the world of project
        management.</p>
        <p>It helps you to focus on a higher-level concepts of
        <i>interfaces</i> (type-signatures) and <i>modules</i> and
        check both the <i>use side</i> and the <i>definition
        side</i>.</p>
        <p><i>ADTs</i> and corresponding <i>modules</i> are at the
        very core of programming (within every <i>paradigm</i>) so
        to beginning with and focus on them is indeed a valuable
        <i>habit</i> to develop.</p>
        <p>Write the tests - your “use side” - before an
        implementation, and check if everything is in accordance
        with your <i>specifications</i>. This is an outline of
        actual design process, insead of day-dreaming and
        hand-waving.</p>
      </div>
    </div>
    <div id="outline-container-org3e3b91e" class="outline-2">
      <h2 id="org3e3b91e">Math</h2>
      <div class="outline-text-2" id="text-org3e3b91e">
        <p>It turns out that before thinking about actual
        interfaces (and type-signatures) even higher-level and mode
        abstract <i>mathematical thinking</i> (and writing) is
        required.</p>
        <p>The two DLSs - of The Set Theory and of the First-Order
        Logic - are at the code of all modern mathematics. Other
        specialized “logics” are occasionally useful.</p>
        <p><i>Always write all the relevant math down</i> (in a
        LaTeX subset of org-mode). This will pay you back
        immensely. First, because you will forget it all in a week.
        Second, because other people can check and even verify your
        reasoning. This is priceless.</p>
      </div>
    </div>
    <div id="outline-container-org089851f" class="outline-2">
      <h2 id="org089851f">UNIX Philosophy + Functional
      Programming</h2>
      <div class="outline-text-2" id="text-org089851f">
        <p>It always looks simple in retrospect. Just take the best
        parts of the UNIX Philosophy (do just one thing but do it
        well, use text streams, files, pipes and sockets) and use
        <code>SML/NJ</code>, <code>Erlang</code>,
        <code>Haskell</code> or <code>Ocaml</code> instead of
        <code>C</code> or <code>C++</code>. Well, <code>SML</code>
        is rather a monument of the glorious times long gone, so
        <code>Ocaml</code> or <code>Haskell</code> but never
        re-implementing the wheel, and just <i>FFI’ing
        everything</i>.</p>
        <p>If you are trapped in the JVM ecosystem, then there is
        <code>Scala 3</code>, which doing almost everything right,
        except, of course, the fucking dependencines and 3 versions
        of the compiler and standard library in a smallest setup.
        Well, with <code>Haskell</code> that is even worse.</p>
        <p>Text streams and FP maps very well with so-called
        <i>Micro-services architecture</i> - as long as you are
        <i>pure functional</i> (Same input - same output. Always.),
        which implies <i>referentially transparent</i>, you can
        really mix and match “services” just like a functional
        programmer mix and match <i>functions</i>. Yes, for real.
        <code>Coursier</code>, <code>Kafka</code> or <code>Twitter
        toolchain</code> are the actual use cases.</p>
        <p>Just getting rid of imperative code (aliasing problems,
        lifetimes, locks, semaphors, etc) and verbose, boated
        sources is already a bliss and an unexpected return of the
        <i>joy of programming</i> which programmers of the Golden
        Age (Common Lisp, Smalltalk, Standard ML, Miranda, Haskell)
        used to feel. <i>Happy, happy, joy, joy</i> (this is from
        the MIT Scheme).</p>
        <p>Using a <i>high level, mostly functional</i> language in
        UNIX instead of <code>C</code> is (unfortunately) not my
        idea. <i>Bell Labs</i> had a research project which
        resulted in development of the <i>Basis Library</i> and a
        couple of books. Today, it seems that <code>Ocaml</code>
        picked everything up where they left. Just like it was with
        SML, a major <i>theorem proover</i> (<code>Coq</code>) is
        the main project for the whole ecosystem, and it has just
        the <i>standard library</i> in dependencies (well,
        almost).</p>
        <p>Another thing to add is what is loosely called
        <i>reactive programming</i> which is just <i>triggers on
        events from an event stream</i>. This is already a mess and
        a contenst in blog post idiocy, but one could use the right
        abstractions (which are streams and typed events to
        pattern-match upon). Some Haskell’s graphics and animation
        libraries got it right.</p>
        <p>Any kind of immutable databases, ledgers, etc. could
        <i>naturally</i> be developed using this approach.
        <i>Datomic</i> of Rich Hickey is an attempt for an
        <i>immutable store</i>. <i>XTZ</i> is a blockchain
        implementation in pure Ocaml, while others still got stuck
        with <code>C and C++</code>.</p>
        <p>The <i>Haskell Platform</i> (GHC + a small set of
        well-designed libraries) and the <i>Ocaml Ecosystem</i>
        (the compiler, tools and the libraries via
        <code>opam</code>) are <i>production-ready</i>
        environments. One always could enrich them with
        <code>Coq</code>, <code>Agda</code> and <code>TLA+</code>
        to reach the level of an <i>art</i> (instead of that
        <i>learn to code in javascript or python</i> fucking
        abomination).</p>
      </div>
    </div>
    <div id="outline-container-orga466125" class="outline-2">
      <h2 id="orga466125">Algebraic types and pattern-matching</h2>
      <div class="outline-text-2" id="text-orga466125">
        <p>Anything could be build out of <i>Algebraic Data
        Types</i>.</p>
        <p>There are <i>AND-types</i> (<code>A, B</code> -
        product-types), <i>OR-types</i> (<code>A | B</code> -
        sum-types) and <i>lambda types</i> (<code>A -&gt; B</code>
        - correspond to exponents).</p>
        <p>Everything becomes self-evident when we think of types
        as <i>finite sets</i> and consider all the individual
        unique mappings (<i>arrows</i>) between the elements of any
        two such sets.</p>
        <p>We could pattern-match on <i>data-constructors</i> which
        conceptually are the same as <i>type-tags</i> for every
        value.</p>
        <p>Logically, we can imagine that each value has an
        implicit <i>type-tag attached to it</i>. Type-tags are as
        old as early LISPs and this, in turn, corresponds to unique
        shapes of common molecular structures in biology.</p>
        <p>A list is a <i>recursive</i> sum-type. So are
        <i>trees</i>. A record is a <i>product type</i> with
        <i>tagged</i> (named) values (parts). A table is a mapping
        (just like a function) from “rows” to “columns”.</p>
        <p>One could think of a table as a <i>list of tuples</i>
        (an ordered sequence of fixed-size “sequences”). The early
        LISPs has been built this way.</p>
      </div>
    </div>
    <div id="outline-container-org22910c4" class="outline-2">
      <h2 id="org22910c4">The Relational Model</h2>
      <div class="outline-text-2" id="text-org22910c4">
        <p>Everything “fits together” because conceptually, at the
        most abstract level it is all just <i>sets of tuples</i>,
        which is the basis of <i>both</i> Functional Languages and
        the Relational Model.</p>
        <p>The crucial principle is that relations are just <i>sets
        of tuples</i>, and the whole relations are <i>immutable
        values</i>, with all the usual nice properties and
        implications.</p>
        <p>Everything is “naturally” <i>typed</i> with Algebraic
        Data Types - a record is just a “named” tuple, which, in
        turn, is a <i>product-type</i>. <i>Sum-types</i> provide
        all the required enumerables.</p>
        <p>There is a simple and obvious <i>relation algebra</i>
        based on the algebra of the Set Theory, with the <i>closure
        property</i>.</p>
        <p>Like any other values, these <i>relation</i> values can
        be passed to and returned from pure <i>functions</i>, used
        within <i>persistent aggregates</i>, put into immutable
        <i>trees</i>, etc.</p>
        <p>This maps well to <i>persistent data structures</i>
        (trees and maps) of functional languages.</p>
        <p>Lists of records (“named” tuples) where the actual
        ordering is irrelevant (unless deliberately <i>sorted</i>)
        is an obvious transition from the abstract universe of Sets
        to the concrete reality of actual representations and
        languages.</p>
      </div>
    </div>
    <div id="outline-container-org99a207f" class="outline-2">
      <h2 id="org99a207f">Managing Complexity</h2>
      <div class="outline-text-2" id="text-org99a207f">
        <p>As long as we are able to model and formally specify our
        domain in the <i>language of mathematics</i>, which is
        basically 2 DSLs -the Sets and the First Order Logic and
        could derive a simple <i>domain-specific /algebra</i>, the
        complexity is under our control.</p>
      </div>
      <div id="outline-container-orgbbd25f5" class="outline-3">
        <h3 id="orgbbd25f5">Zooming in and out</h3>
        <div class="outline-text-3" id="text-orgbbd25f5">
          <p>This is the most important thing in managing
          complexity - the ability to zoom in from a mathematical
          model to actual language types and implementations inside
          modules and back to the most general and abstract
          notions.</p>
          <p>This ability is the key to success and the biginning
          of an art.’</p>
        </div>
      </div>
      <div id="outline-container-orgf98865b" class="outline-3">
        <h3 id="orgf98865b">Formal systems</h3>
        <div class="outline-text-3" id="text-orgf98865b">
          <p>As long as we are writing math we are able to formally
          verify it.</p>
          <p><code>TLA+</code>, <code>Agda</code> and
          <code>Coq</code> are the tools of the trade. Notice that
          the larter has an embedded pure functional language with
          algebraic types and pattern matching, which is, again,
          the universal core language.</p>
        </div>
      </div>
    </div>
    <div id="outline-container-org001822b" class="outline-2">
      <h2 id="org001822b">Languages</h2>
      <div class="outline-text-2" id="text-org001822b">
        <p>The modern descendants of the ML-family of languages are
        an “ideal” choice.</p>
        <p>Haskell is particularly good, because it
        <i>restricts</i> and has the most advanced <i>type
        system</i>.</p>
        <p>Ocaml shines with its <i>module system</i> and
        <i>syntactic extensions</i>.</p>
        <p>Scala 3 is also good, given that we use our own
        <i>simple</i> libraries (made by ripping off the essence
        from an over-“engineered” bullshit).</p>
      </div>
    </div>
    <div id="outline-container-org2dd6c1d" class="outline-2">
      <h2 id="org2dd6c1d">Lists, Records, Queues, Streams,
      Logs</h2>
      <div class="outline-text-2" id="text-org2dd6c1d">
        <ul class="org-ul">
          <li>Lists are <i>position ordered</i></li>
          <li>Records are <i>by name</i> (associative)</li>
          <li>Logs are <i>lists of strings which represent
          records</i> (containing a <i>timestamp</i>)</li>
          <li>Queues are async messages <i>without knowing anything
          about the receiver</i>.</li>
          <li>Streams are <i>serialized events</i> (by sense organs
          of perception).</li>
        </ul>
        <p>Which a <i>by name</i> pattern one don’t have to know
        <i>what else is there</i>. This implies new names (or keys)
        could be <i>added later</i> without affection anything
        which is already there.</p>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: schiptsov@gmail.com</p>
    <p class="email">Email: <a href=
    "mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
    <p class="date">Created: 2022-10-17 Mon 09:45</p>
  </div>
</body>
</html>
