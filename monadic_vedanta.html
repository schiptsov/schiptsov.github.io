<!DOCTYPE html>
<html lang="en">
<head>
  <!-- 2022-04-10 Sun 19:11 -->
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <title>Monadic Vedanta</title>
  <meta name="author" content="&lt;schiptsov@gmail.com&gt;">
  <meta name="description" content=
  "End of Knowledge about Monads in Haskell">
  <meta name="generator" content="Org Mode">
  <link rel='stylesheet' type='text/css' href='css/main.css'>
</head>
<body>
  <div id="org-div-home-and-up">
    <a accesskey="h" href="">UP</a> | <a accesskey="H" href=
    "index.html">HOME</a>
  </div>
  <div id="content" class="content">
    <header>
      <h1 class="title">Monadic Vedanta</h1>
    </header>
    <p>The problem why <code>Monads</code> <i>in Haskell</i> are so
    confusing is that we (at least I) are trying to understand it
    <i>bottom-up</i>, from what we see in some crappy code. Not
    just that, but when we search for an explanation, shitposts by
    narcissistic imposers is what Google Search will give you
    first.</p>
    <p>It might take years (at least for me) to sort everything
    out, and reduce everything back to <i>What Is</i>.</p>
    <p>It took so long because I have to went through piles and
    piles of bullshit, including the Category Theory, to <i>make
    sure</i> that <i>it is completely irrelevant</i> in this
    context.</p>
    <div id="outline-container-orgf2569ae" class="outline-2">
      <h2 id="orgf2569ae">The Proper Philosophy</h2>
      <div class="outline-text-2" id="text-orgf2569ae">
        <p><i>Life Itself</i> has been evolved upon certain
        molecular structures, which are made out of <i>Atoms</i>.
        Life does not know anything about their nature, it is just
        using them as <i>given</i>.</p>
        <p>If it could make any assumptions, that would be, as we
        assume, that they are <i>indivisible</i> and
        <i>indestructible</i>, and <i>some</i> particular molecular
        structures such as <i>aminoacids</i> or RNAs are
        <i>immutable</i>.</p>
        <p>The <i>fact</i> that atoms can actually be broken in
        certain conditions (created by humans on this planet) is
        <i>irrelevant</i>, because in the actual environment in
        which Life has been evolved <i>such conditions do not
        arise</i>.</p>
        <p>What we have here is a <i>very real, not imaginary,
        abstraction barrier</i>, so real an actual, that literally
        everything within you and around you is made upon it.</p>
        <p>And <i>this</i> is the <i>Reality First Principle</i>
        for functional programming - atomicity and immutability of
        base structures, which is only apparent.</p>
      </div>
    </div>
    <div id="outline-container-org23bbfac" class="outline-2">
      <h2 id="org23bbfac">The Highest level</h2>
      <div class="outline-text-2" id="text-org23bbfac">
        <p>At a <i>highest, most abstract level</i> a Monad <i>in
        Haskell</i> is a generalization of an <i>abstraction
        barrier</i> similar to that one which holds <i>Life
        Itself</i>.</p>
        <p>Functions on <i>Monadic Values</i> (of a particular
        type) are as pure as mathematical functions (could be
        calculated by pure substitution with pen an paper),
        <i>referential transparency</i> is preserved.</p>
        <p><i>What is going on inside these values is beyond the
        abstraction barrier</i> and <i>literally cannot be seen</i>
        by pure Haskell code (the code only declare what to do with
        these values, including pattern matching on value’s
        structure).</p>
        <p>These are <i>the same notions (of an impenetrable
        abstraction barrier)</i>, and it <i>is not</i> “abstract”
        or imaginary. Everything is real.</p>
      </div>
    </div>
    <div id="outline-container-orgbe91c1b" class="outline-2">
      <h2 id="orgbe91c1b">&gt;&gt;=</h2>
      <div class="outline-text-2" id="text-orgbe91c1b">
        <p>The (&gt;&gt;=) function (called bind) which does
        <i>re-binding</i> and <i>sequencing</i> should be
        considered <i>impure</i>, because it (and only it) has
        access to the <i>internal state</i> and <i>actual
        representations</i>.</p>
        <p>However, the <i>code that uses</i> (&gt;&gt;=) is as
        pure as math or logic.</p>
        <p>The type system guarantees that no code could “see” or
        access any value behind the monad interface (abstraction
        barrier). (&gt;&gt;=) and only (&gt;&gt;=) can access and
        pattern-match (but not “see”, because Haskell is
        <i>declarative</i>.).</p>
        <p>This is exactly how Haskell code is pure (as math or
        logic) in the presence of IO, State transformation and
        side-effects. All these are beyond the abstraction barrier
        with the Monad type-class establishes, and the type system
        <i>enforses</i>.</p>
        <p>Each <i>instance</i> of a Monad (an actual type) hides
        all its “stuff” behind a standardized interface, which
        separates the pure code from impure.</p>
        <p>And that is really it. No more, no less.</p>
      </div>
    </div>
    <div id="outline-container-org9cb34f5" class="outline-2">
      <h2 id="org9cb34f5">Passing the Whole World</h2>
      <div class="outline-text-2" id="text-org9cb34f5">
        <p>This <i>metaphor</i> is both philosophically funny and
        useful. In an abstract theory, a function <i>is indeed
        pure</i> if it takes a <i>snapshot of the whole
        universe</i> and returns a value together with the <i>whole
        universe modified by itself</i>.</p>
        <p>In reality this is a form of an explicit
        <i>serialization</i> (via nesting of calls and explicit
        passing of a value - nested <code>lets</code>, which are
        semantically equivalent to <i>nested lambdas</i>) which is
        required for <i>sequencing of</i> <code>IO</code> actions,
        since Haskell is a <i>call-by-need</i> language.</p>
        <p>Nested function calls and implicit passing of a values
        <i>inside a Monadic context</i> (behind the abstraction
        barrier) is the most common idiom.</p>
        <p>Nesting of expressions is the <i>natural</i> way to
        establish an evaluation order in a language with <i>lazy
        semantics</i>.</p>
        <p>Passing of “RealWorld” values ensures “threading”- than
        <i>no two IO contexts ever overlap</i>.</p>
        <p><code>IO</code> is a <i>type synonym</i> defined in the
        following way:</p>
        <div class="org-src-container">
          <pre class="src src-haskell"><span style=
          "color: #81A1C1;">type</span> <span style=
          "color: #8FBCBB;">IO</span> a  <span style=
          "color: #D8DEE9;">=</span>  <span style=
          "color: #8FBCBB;">RealWorld</span> <span style=
          "color: #D8DEE9;">-&gt;</span> <span style=
          "color: #81A1C1;">(</span>a, <span style=
          "color: #8FBCBB;">RealWorld</span><span style=
          "color: #81A1C1;">)</span>
</pre>
        </div>
      </div>
    </div>
    <div id="outline-container-org03f2a91" class="outline-2">
      <h2 id="org03f2a91">an ADT</h2>
      <div class="outline-text-2" id="text-org03f2a91">
        <p>Technically, it is an ADT as defined by Barbara Liskov.
        There is an interface, which is what the <i>pure code</i>
        “sees” and uses. There is an <i>actual implementation</i>,
        based on some <i>particular representation</i> (actual
        <i>data structure</i>) hidden behind the <i>interface</i>,
        exactly as intended.</p>
        <p>All the most fundamental concepts of programming are
        there in play.</p>
      </div>
    </div>
    <div id="outline-container-orgf46c93b" class="outline-2">
      <h2 id="orgf46c93b">Actual representation</h2>
      <div class="outline-text-2" id="text-orgf46c93b">
        <p>At the lowest level there is an impure code which
        manipulates data in memory, like everything else.</p>
        <p>The purity ends when the <i>main</i> function of a
        Haskell program returns a <i>pure expression</i> (to be
        <i>eventually</i> evaluated by the runtime), which is a
        type-checked <i>specialized state machine, defined in pure
        logic</i>.</p>
      </div>
    </div>
    <div id="outline-container-org7b2eee9" class="outline-2">
      <h2 id="org7b2eee9">State Monad</h2>
      <div class="outline-text-2" id="text-org7b2eee9">
        <p>It is just a lambda which returns a <i>pair</i> of
        values. Lambda, so that they can be composed sequentially
        (yes, just <i>nested lambdas</i>) by
        <code>&gt;&gt;=</code>.</p>
        <p>The two values of a <i>pair</i> are at the different
        sides of an <i>abstraction barrier</i>. The
        <code>State</code> cannot be seen or accessed outside of
        the Monad.</p>
        <p>The lambda (which is called a <i>State Transformer</i>)
        captures the value, and it is <i>lifted</i> into this
        particular <i>Monadic context</i> “forever”.</p>
        <p>The actual <code>State</code> <i>type</i> and how
        exactly the <i>values of that type</i> are actually handled
        is encapsulated inside a particular instance of a
        <code>Monad</code> <i>type-class</i> and it does not
        pollute the pure code.</p>
        <p>Moreover, the code is still <i>declarative</i> and will
        be evaluated <i>eventually</i>, so it is literally a pure
        logical expression which declares <i>what is to be done
        with Monadic values</i>. Referential transparency still
        holds.</p>
      </div>
    </div>
  </div>
  <div id="postamble" class="status">
    <p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
    <p class="date">Created: 2022-04-10 Sun 19:11</p>
  </div>
</body>
</html>
