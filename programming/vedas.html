<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-12-09 Fri 22:16 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Vedas of programming</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">The Vedas of programming</h1>
</header><p>
In the old books, published in the previous century, just before 2000,
the old-timers, who as a rule had a deep mathematical or software
engineering background (like Barbara Liskov or Joe Armstrong) it has
been stated that applying of just a few fundamental principles will  solve the most problems, which arise in programming of complex systems.
</p>

<p>
The <i>Abstraction Principle</i> of Bruce MacLennan, and the <i>Data Abstraction Principle</i> of Barbara Liskov are the most fundamental ones and underline the whole <i>Modular Programming</i> paradigm, which is the main methodology for dealing with inherent complexity.
</p>

<p>
Abstracting out a <i>recurring (re-emerging) pattern</i> and to give it a name (which is a <i>reference</i> for it to be reused) is how our minds evolved to &ldquo;work&rdquo;. This is how we invented our mathematics.
</p>

<p>
<i>Composing</i> these abstracted out notions is what functional programming is about. Functional composition and interfaces are the very core of any programming. It reflects something deeper that just conventions - it is about how complex systems of nature has been built.
</p>

<p>
Most of the books of the previous century teach <i>principles</i>, not particulars. The universal data structures (lists or sequences, trees, and lookup tables) and their time and space complexities has been studied in details and declared to be good-enough for everything.
</p>

<p>
Consistent Hashing algorithms and resulting hash-tables has been considered the last major innovation. Table-based languages, like Clojure or Lua emerged as a result, and these were the last good things that happened.
</p>

<div id="outline-container-orgeba8fd2" class="outline-2">
<h2 id="orgeba8fd2">Decomposition</h2>
<div class="outline-text-2" id="text-orgeba8fd2">
<p>
The best metaphor I know is how a competent and experienced mechanics
disassemble a rusted engine, carefully examine and fix (or replace)
every single part and then assemble the engine back just like a new. You
can get lots of such videos on Facebook.
</p>

<p>
Of course, programming is very different kind of activity, but the
principles are the same. No one gives you an engine, you will have some
<i>problem domain</i> instead.
</p>

<p>
Nevertheless, the first thing to do is to disentangle, decompose and
take apart the problem (into subproblems, subsystems, core concepts,
<i>rules</i> and communication <i>protocols</i>, which are also <i>sets of rules</i>).
</p>

<p>
One have to &ldquo;disassemble&rdquo; everything down to sets, formal logic and
particular algorithms (which has to be derived from the rules of
&ldquo;business logic&rdquo;).
</p>

<p>
Only after everything &ldquo;part&rdquo; (or detali) has been &ldquo;placed on the table&rdquo;
(being formally specified) one can begin to assemble an &ldquo;engine&rdquo; (this
is actually a good metaphor!).
</p>

<p>
One begin to <i>prototype</i> by enumerating the core <i>algebraic data types</i>, with corresponding
<i>modules</i> that exports public <i>interfaces</i>. Then one tries partially
implement these interfaces and to compose actual functions. This is a
<i>bottom-up</i> process.
</p>

<p>
<i>Partial implementation</i> is possible because both product- and sum-types
can be <i>partially specified</i> and still be correct (just a few slots of a
record, just a couple of data-constructors of a sum-type). Functions
defined by <i>pattern-matching</i> will be correct by definition.
</p>

<p>
The whole thing is a <i>spiral-shaped</i> process, where previous results act
as foundation of the next iteration or a &ldquo;sprint&rdquo;.
</p>

<p>
The key point here is that <i>both</i> actual representations and conceptual
understanding are mutually refined (yes, just like a <i>mutual recursion</i>)
and everything, including formal specifications and validation tests
gets <i>simplified</i> and <i>reduced to the fundamental data structures and
corresponding  standard idioms</i>. This is how one does assembling - by
function composition.
</p>
</div>
</div>
<div id="outline-container-org8c67cfe" class="outline-2">
<h2 id="org8c67cfe">Use the fundamentals</h2>
<div class="outline-text-2" id="text-org8c67cfe">
<p>
In developing, and especially in prototyping of a system the most crucial part is to restrict oneself to the fundamental, well-understood <i>universal</i> building blocks - well-typed function and data abstractions.
</p>

<p>
It is difficult to sell this in the modern world, but this is <i>the way</i> to program.o
</p>

<p>
Abstract Data Types, Algebraic Data Types and functions defined by pattern-matching (in small, specialized, loose-coupled modules) is all you need.
</p>

<p>
This was the major result and the peak achievement of the Golden Age. <i>All You Need Is Lambda</i>, was the golden mantra of the time. This is still true. Lambda and a lot of syntactic sugar and advanced typing, which is what Haskell is.
</p>

<p>
In short, if one does not want to fail with a programming project one has to do it in the now &ldquo;ancient&rdquo; way, because not just this is <i>the only way</i>, but it is already the Vedas of programming.
</p>

<p>
The <i>Upanishads</i> of programming would explain <i>Whys</i> and <i>Hows</i> and this is what I am trying to write time and again.
</p>

<p>
Remember that things like Erlang or Scala or Ocaml has been actual experimental results to confirm our principles and methodologies. You probably know that WhatApp is Erlang and Twitter is Scala.
</p>

<p>
Why these things work is exactly because they <i>compose</i> well-typed and well-understood <i>fundamental abstractions</i> as stable intermediate building blocks. You probably should do it too.
</p>
</div>
</div>
<div id="outline-container-org9dac95d" class="outline-2">
<h2 id="org9dac95d">How do we program?</h2>
<div class="outline-text-2" id="text-org9dac95d">
<p>
Well, we just do what Erlang and Clojure authors advocated
We write small pure functions (turn functions into pure ones by passing a <i>context</i>).
We FFI everything (no more hundreds of idiotic low-effort dependencies)
We encapsulate exception throwing stuff inside a Monads.
</p>

<p>
Basically, we do a <i>Bird-Wadler textbook</i> style Haskell <i>without dependencies</i>.
</p>

<p>
We write our libraries as <i>layered DSLs</i> (a-la TeX or the Esher pictures DSL).
</p>

<p>
With some effort other decent languages (Ocaml, Scala 3, F#) can be used in the similar manner. Less is indeed more.
</p>

<p>
And this is it. This is Vedanta all over again.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2022-12-09 Fri 22:16</p>
</div>
</body>
</html>