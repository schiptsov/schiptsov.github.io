<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-03-06 Mon 13:08 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vedanta</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Vedanta</h1>
</header><p>
People who have studied logic and mathematics of sets and function composition
have noticed some commonalities, generalized them, and later discovered that
their generalized abstractions are of the same &ldquo;patterns&rdquo;.
</p>

<p>
The &ldquo;things&rdquo; that come up (noticed by the mind of an external observer) again
and again are <i>steps</i> (&ldquo;arrows&rdquo;), <i>environments</i> (&ldquo;being present in the same
locality&rdquo;) and <i>contexts</i> (local frames, &ldquo;packets&rdquo; of the environment).
</p>

<p>
They also have noticed that there are &ldquo;forks&rdquo; and &ldquo;joins&rdquo; everywhere, and even
if they <i>looks the same</i> once you rotated one, they are fundamentally different
things. Forks exists only as &ldquo;hypothetical possibilities&rdquo; and &ldquo;alternative
paths&rdquo; or &ldquo;possible choices&rdquo;, while a process (<i>the actual path being taken</i>) is
always &ldquo;linear&rdquo; (<i>without any forks</i> in principle).
</p>

<p>
Forks are tricky. When you ask yourself what determines which path will be taken
in a pure-logical (or mathematical) <i>declarative description of a process</i>, the
answer is <i>always</i> - this depends on a current context, which is being <i>passed
along</i> as an implicit parameter (withing a bigger &ldquo;closure&rdquo;).
</p>

<p>
What is a <i>closure</i>? Well, it is a generalization of a <i>snapshot of you and your locality</i> (the relevant
part of the global environment). The old-timers who designed Scheme and early
Lisps used the right terminology. What you can or cannot do depends on your
<i>locality</i> (local environment) and your <i>internal state</i> (your inner environment or
your current <i>context</i>).
</p>

<p>
It is somehow &ldquo;naturally follows&rdquo; that the environments (bindings), required local contexts (frames), just like closures, has to be maintained by the runtime, to provide a stable &ldquo;planet&rdquo; for processes. Scheme and Erlang guys got it right, and. efficiency aside, nested lists of pairs were enough for everything.
</p>

<p>
These universal notions connect logic, math and functional programming back to
reality, to What Is, from where it arose and came to be.
</p>

<p>
Never try to understand things backwards - <i>Reality (comes) First</i>,
not the Mind. The mind observes common patterns, abstracts out and generalizes, not the other
way around, like the Platonist idiots would be shouting at you. Knowing just that
will take your programming (math and logic) to the next level.
</p>

<p>
There is another principle to understand. Mother Nature have evolved (by the
process of trial and error) some <i>intermediate stable forms and patterns</i> upon
which everything Is, including Life Itself.
</p>

<p>
One such pattern is that an information has been encoded in some supposedly
and hopefully immutable (actually immutable from the Life&rsquo;s point of view) and
this information is being <i>interpreted and is running</i> by a &ldquo;runtime environment&rdquo;,
which is what a single cell is.
</p>

<p>
To be precise, the cell is the &ldquo;language runtime&rdquo;, and the universe is the &ldquo;computer&rdquo;.
</p>

<p>
What connects these universal notions - the classic logic and a cells - is that
the <i>underlying patterns</i> are not just similar, they are exactly the same. There
are environments, contexts and sequential processes.
</p>

<p>
The &ldquo;forks&rdquo; are encoded in the DNA but only one alternative is <i>selected</i> (when
not the result is what we call a <i>cancer</i>).
</p>

<p>
To put it simple, <i>locality</i> is a physical notion, while alternatives or forks are
<i>information</i>. Yes, information (about the environment) is &ldquo;real&rdquo;, and the fundamental principle is that
it must match the actual environment &ldquo;perfectly&rdquo;.
</p>

<p>
Information is also <i>a blueprint (or a template)</i> for an actual process, and this
is, again, the right terminology by the famous MIT guys. This brings us to the
conclusion that an implementation of a pure, declarative language (such like
Haskell) by a graph-reduction runtime (which is an evaluation of a pure,
declarative, well-typed <i>abstract state-machine</i> by an impure imperative electrical
machine) is the right thing to do. This is how cell evaluates its DNA (well, mRNA).
</p>

<p>
Notice, that unnecessary, redundant abstractions (which is the root of all
evil) do not &ldquo;survive&rdquo; in the evolutionary setting, being eventually replaced by
&ldquo;better&rdquo; (closer to What Is) ones. Also notice that the so-called &ldquo;technical
debt&rdquo; is very real and it is literally building on top of &ldquo;crappy structures&rdquo;
(which eventually cannot be undone (replaced) by the process of Evolution).
</p>

<p>
Fortunately, good programmers, can change the <i>core types</i> early and quicky once we maintain the
proper stable interfaces (abstraction barriers).  This is also a universal
pattern from biology and this particular one makes evolution (of stable
intermediate forms) <i>faster</i>.
</p>

<p>
Of course, this subject is wast. There are the fundamental, universal notions of
<i>nesting</i>, of <i>abstraction barriers</i> (they are real, as real as atoms from which DNA
has been built), <i>enzymes</i> which some are <i>operationally</i> pure functions
(context-independent) parameterized by ions, and some are <i>procedures</i> (which
depend upon a current context - presence or absence of certain &ldquo;things&rdquo;).
</p>

<p>
Some enzymes are &ldquo;blocking&rdquo; (until required ion is present), some are
&ldquo;asynchronous&rdquo; - they just emit structures, but the universal principle is that
an environment, local contexts and sequential processes are there.
</p>

<p>
So, when we look at things like Haskell or Scala 3, we should try to <i>zoom
through</i> the layers of abstractions and to see the Reality through the <i>veil of
abstract mental constructions</i> the Mind pollutes and deludes itself with.
</p>

<p>
<i>Zoom in and out, see (and break) through</i>. This is the right understanding.
</p>

<p>
It is, of course, not possible to put everything into a single text file, but it
possible to sketch a big picture and point to some of the right principles, from
which everything follows.
</p>

<p>
Everything what is not bullshit is reducible back to What Is and its universal
patterns. In a symbolic form it will be reduced to some shapes of <i>dots and
arrows</i>, nested circles, common <i>forms</i> and <i>structures</i>. Your Functors would become
an abstract generalization of <i>shape-preserving transformations</i>, your Kleisli
arrows would become an abstraction-boundary crossing transformations, and
Kleisli triplets would be an abstraction of a &ldquo;fork&rdquo; (two possibilities), etc.
</p>

<p>
When you nest types you will nest subsets and &ldquo;decorate with additional tags&rdquo;,
which corresponds to <i>specializing</i> - moving through the layers of abstractions
from general to specific. Generic code would be capturing of actual
commonalities (of a common structure), and duck-typing (Haskell type-classes)
would be the way to capture common shapes and common behaviors (behaviors in
Erlang are just <i>generic modules</i>).
</p>

<p>
Everything is reducible, with some effort, to just a few basic pictures of dots, arrows and
nested circles - the universal basic building blocks for a <i>declarative
state-machine</i> which can be executed by a universal runtime. It is not just math
or logic (executed using a finite set of rules by the runtime of a brain). It is
more general (and fundamental) than that.
</p>

<p>
About that concurrency stuff - the fundamental pattern is that &ldquo;an event&rdquo; has to
arrive through a different &ldquo;arrow&rdquo;, so there is an additional incoming arrow,
and what has a distinctly different shape belongs to a distinctly different
type. Not surprisingly, <i>async</i> functions belong to its own <i>type-class</i> and even its
own distinct <i>Monad</i>. These things are structurally different and &ldquo;naturally&rdquo; can be composed
only with its own kind, behind an abstraction barrier.
</p>

<p>
Last but not least, everything is structurally encoded - DNA, language centers
of the brain, any AI models, but the basic building blocks are the same.
</p>

<p>
This is how zooming and seeing works in practice.
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-03-06 Mon 13:08</p>
</div>
</body>
</html>