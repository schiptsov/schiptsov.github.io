<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-03-27 Mon 14:10 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Scala3</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Scala3</h1>
</header><p>
When the language specification and the compiler are done, we face a
slow, painful but doable <code>2 -&gt; 3</code> transition, similar to what Python went
through.
</p>

<p>
It is not just matter of accessing old classes, it is an effort to
rewrite parts of important codebases (Spark, Kafka, the Twitter stack)
to use the new standard library and its better abstractions (due to
better typing).
</p>

<p>
The main goal was, and still is to write high-level libraries as layers of
functional DSLs.
</p>

<p>
However, over-&ldquo;engineering&rdquo;, over-abstraction and even over-DSLing are the
actual problems. Over-complicated bullshit is not a solution to complexity, just
like an idiotic pretentious, over-verbose language used by liberal-arts and
humanties.
</p>

<p>
To choose <i>just right abstractions</i> and just right level of
wrapping (proper types) is what constitutes <i>the art part</i> of the craft.
</p>

<p>
Things like <code>scalatest</code>, <code>cats</code> and <code>zio2</code> are the real-world examples of such layered
DSLs. This is the way to program, and the real understanding comes from the
principles behind the syntactic sugar and the <i>higher-kinded types</i>.
</p>

<div id="outline-container-org6f805af" class="outline-2">
<h2 id="org6f805af">Overview</h2>
<div class="outline-text-2" id="text-org6f805af">
<p>
It is much better to think in terms of <i>nested Sets of type-tagged structured
values</i>.
With proper universal <i>nesting</i> almost everything can be abstracted as such a
value. Objects may have fields and methods, traits may have <i>types, fields,
methods</i> and <i>other traits</i>, which may have types, methods and other traits&#x2026;
At a higher level, <i>modules</i> and whole <i>packages</i> are such &ldquo;values&rdquo; too.
</p>

<p>
<code>Scala 3</code> import system hints at this universality, allowing one to import
everything from everything almost uniformly. This is a consequence of a proper
design, and proper modeling based on just Sets and (Second Order) Logic.
</p>

<p>
<code>Scala 3</code> got a lot of <i>principle-guided unification</i> from being a cool collection of
<i>ad-hook</i> design decisions. It is by far the best-designed language out there,
especially compared to Java or C++.
</p>
</div>

<div id="outline-container-org996dd69" class="outline-3">
<h3 id="org996dd69">Product types</h3>
<div class="outline-text-3" id="text-org996dd69">
<p>
<i>Case-classes</i> are used to define <i>immutable values which have its own structure</i> and
&ldquo;normal&rdquo; classes can create <i>mutable record types</i>. <i>Companion objects</i> provide an
additional  <i>name-space</i>. /Extensions are also useful.
</p>
</div>
</div>
<div id="outline-container-org57a592a" class="outline-3">
<h3 id="org57a592a">Sum types</h3>
<div class="outline-text-3" id="text-org57a592a">
<p>
<i>Enums</i> are Scala&rsquo;s  attempt on generalized <i>sum-types</i>, or even GADTs, and they
seem OK due to the ability to define fields and methods, just like in a
<i>companion object</i>. They can be <i>parameterized</i>, just like Traits.
</p>
</div>
</div>
<div id="outline-container-orgc5f7fda" class="outline-3">
<h3 id="orgc5f7fda">Type-classes</h3>
<div class="outline-text-3" id="text-orgc5f7fda">
<p>
Parameterized <i>Traits</i> are now the solid basis of proper <i>type-classes</i>, which are as
fundamental as Liskov&rsquo;s ADTs, and one should <i>abstract out with traits</i>.
</p>

<p>
Just like ADTs, type-classes (based on composable <i>Traits</i>) define <i>abstract
interfaces</i> (to be implemented), thus introducing an <i>abstraction barrier</i> by
abstracting away everything about implementations.
</p>

<p>
I really hope that they at least attempted to unify various <i>in-house
implementations</i> of <i>Streams</i> and <i>Futures</i> and what not. There is no easy or
quick way to <i>evolve stable intermediate forms</i> which is a principal requirement for
an ongoing evolutionary process.
</p>

<p>
The mantra <i>Principle-based is better than rule-based</i> should be the motto
of <code>Scala 3</code>.
</p>

<p>
The sad thing is refusal to just copy fundamental innovations from other
languages
</p>
<ul class="org-ul">
<li><code>where</code> clauses from CLU</li>
<li>modules of Ocaml (it has to be the Java way)</li>
<li>Some Haskell&rsquo;s typing extensions which have proven to be useful.</li>
</ul>

<p>
Anyway, whatever.
</p>
</div>
</div>
</div>
<div id="outline-container-orgaf3cbb0" class="outline-2">
<h2 id="orgaf3cbb0">Modern tools</h2>
<div class="outline-text-2" id="text-orgaf3cbb0">
<ul class="org-ul">
<li><code>cs</code> -  <i>artifact manager</i></li>
<li><code>amm</code> - <i>advanced REPL</i></li>
</ul>

<p>
The Compiler, <code>sbt</code> and <code>amm</code>
</p>
<div class="org-src-container">
<pre class="src src-bash">cs setup
</pre>
</div>

<p>
Language-server, linter, formater
</p>
<div class="org-src-container">
<pre class="src src-bash">cs install bloop metals scalafix scalafmt
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">cs update
</pre>
</div>

<p>
Launch the REPL
</p>
<div class="org-src-container">
<pre class="src src-bash">cs launch ammonite --scala 3.2.1
</pre>
</div>
<p>
import straight from <code>Maven</code>
</p>
<pre class="example" id="org3a156a8">
import $ivy.`com.typesafe.akka:akka-stream_3:2.7.0`
</pre>
</div>
<div id="outline-container-org0abc549" class="outline-3">
<h3 id="org0abc549">Basic configuration</h3>
<div class="outline-text-3" id="text-org0abc549">
<p>
add this to the <code>build.sbt</code> file
</p>
<pre class="example" id="org1aa0da0">
val scala3Version = "3.2.1"
val AkkaVersion = "2.8.0-M1"

ThisBuild / scalaVersion := scala3Version
ThisBuild / scalacOptions ++= Seq("-language:_", "-deprecation")

lazy val root = project
  .in(file("."))
  .settings(

    scalaVersion := scala3Version,

    libraryDependencies += Seq("com.typesafe.akka" %% "akka-http" % AkkaVersion,
                               "org.scalatest"     %% "scalatest" % "3.2.14" % Test)
  )
</pre>
<p>
and <code>project/plugins.sbt</code> is
</p>
<pre class="example" id="orgb740934">
addSbtPlugin("ch.epfl.scala" % "sbt-bloop" % "1.5.4")

addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.10.4")
addSbtPlugin("org.scalameta" % "sbt-scalafmt" % "2.4.6")
</pre>
</div>
</div>
</div>
<div id="outline-container-org0eb2d0e" class="outline-2">
<h2 id="org0eb2d0e">Editor support</h2>
<div class="outline-text-2" id="text-org0eb2d0e">
<p>
The <i>Giga Chad</i> Odersky and the team are using <i>VSCode</i>, so it almost always works.
Vim and Emacs require some effort.
</p>

<p>
Be aware of which <code>sbt</code> binary is in your <code>$PATH</code>, which version is
specified in <code>project/build.properties</code> and which version has been
installed by <code>cs</code>. Usually there is a version mismatch.
</p>

<p>
Older <code>Vim</code> plugins check by calling <code>scalac</code>, so make sure there is no <i>Scala2</i> <code>scalac</code>
binary in the <code>$PATH</code>. By default Scala3 calls the compiler <code>scala3-compiler</code>.
</p>

<p>
Since <code>cs</code> is the modern tool of choice, make sure your <code>$HOME/.local/share/coursier/bin/</code> is in the <code>$PATH</code>
</p>

<p>
<code>scalafmt</code> needs to specify a <i>dialect</i> in the <code>.scalafmt.conf</code>.
</p>
</div>
<div id="outline-container-org6e186ca" class="outline-3">
<h3 id="org6e186ca">Metals</h3>
<div class="outline-text-3" id="text-org6e186ca">
<p>
The only LSP-server available is <code>metals</code> but it is buggy as fuck. It
relies on <code>bloop</code>, so make sure it is installed by <code>cs</code>.
</p>

<p>
It fails with idiotic errors (cannot start <code>bsp</code>, etc) when you have
<i>proxy</i> variables set in your shell environment.
</p>

<p>
Degenerates cannot ignore <i>proxy settings</i> for <i>localhost</i> connections.
</p>

<p>
They are also trying to install big <code>jars</code> in background, not being aware
that there are millions of people behind crappy ADSL lines in the third
world.
</p>

<p>
The fucking crap failed with <i>timed out exceptions</i>, leaving everything in an
inconsistent state.
</p>

<p>
It is trying to install <code>scalafmt</code> and other tools by itsef, while they are
already installed by <code>cs</code>, which is the default, preferred way to do this in Scala.
</p>
</div>
</div>
</div>

<div id="outline-container-org90bf288" class="outline-2">
<h2 id="org90bf288">Better abstractions</h2>
<div class="outline-text-2" id="text-org90bf288">
<p>
Refinement of <i>implicits</i> (of implicit <i>contexts</i>) by using a common
mathematical jargon.
</p>

<p>
The general principle of a <i>context</i> is that one does not have to always mention
some properties or attributes.
</p>

<p>
Conceptually similar to <i>partial application</i>, so one does not have to
pass it all around.
</p>

<p>
An implicit value can be &ldquo;inferred&rdquo; by the compiler or <i>selected explicitly</i>
among many.
</p>
</div>
<div id="outline-container-org0b03300" class="outline-3">
<h3 id="org0b03300">Using (clauses)</h3>
<div class="outline-text-3" id="text-org0b03300">
<p>
Optional arguments with <i>default values</i> which can be omitted at a <i>call site</i>.
</p>

<p>
Values should be automatically provided by the <i>context</i>.
</p>
</div>
</div>
<div id="outline-container-org882cdbc" class="outline-3">
<h3 id="org882cdbc">Given (instances)</h3>
<div class="outline-text-3" id="text-org882cdbc">
<p>
This corresponds to some &ldquo;standard property&rdquo; that we always assume -
<i>given that&#x2026;</i>. The common synonym is <i>provided that&#x2026;</i>
</p>

<p>
Define <i>terms</i> that can be used <i>by the compiler</i> to fill in the <i>missing
arguments</i>.
</p>
</div>
</div>
</div>

<div id="outline-container-org5203da9" class="outline-2">
<h2 id="org5203da9">Libraries</h2>
<div class="outline-text-2" id="text-org5203da9">
<p>
Most of them are over-&ldquo;engineered&rdquo; and bloated, without any effort of making the
abstractions <i>minimal</i> and &ldquo;just right&rdquo; (optimal). Such &ldquo;natural
selection&rdquo; (of gradual refinement and reduction to a local optimum)
takes decades (like Common Lisp, Ocaml stdlib or Haskell&rsquo;s prelude).
</p>

<p>
Most of corporate code are of <i>low-effort</i>, and mostly &ldquo;copying&rdquo; of <i>imperative</i> implementations from one another.
</p>
<ul class="org-ul">
<li><code>zio2</code> - functional style I/O</li>
<li><code>cats</code> - some standard <i>type-classes</i> for common <i>algebraic structures</i>.</li>
<li><code>akka</code> - the supposedly done right <i>basic building</i> blocks. Use it.</li>
<li>The <code>Twitter stack</code> (still Scala 2)</li>
<li><code>Kafka</code> - steams</li>
<li><code>Spark</code> - the <i>killer-app</i> (still Scala 2)</li>
</ul>
</div>
</div>

<div id="outline-container-org6d2a6de" class="outline-2">
<h2 id="org6d2a6de">Coming home</h2>
<div class="outline-text-2" id="text-org6d2a6de">
<pre class="example" id="org4b32300">
package s3.payload

import akka.http.scaladsl.model.Uri

import java.net.URLEncoder
import java.io.UnsupportedEncodingException

import scala.sys.process.*

import s3.keys.{getSecretKey, privateKeyFile}

// We shall use their (Binance's) terminology consistently
// hoping that they use it consistently too

// They call this /Singed Payload/

// functions for constructing Signed Payloads

// local type aliases
type QueryString  = String
type DigestSHA256 = String

// This extension can be imported from this module
extension (uri: Uri)
  def withSignature: Uri =
    uri.rawQueryString match
      case Some(s) =&gt;
        uri.withRawQueryString(addSignature(s), Uri.ParsingMode.Strict)
      case None =&gt; uri

  def addSignature(s: QueryString): QueryString =
    s ++ f"?signature=${digest(s)}"

def digest(q: QueryString): DigestSHA256 =
  val sk = getSecretKey
  val a =
    f"bash -c \"echo -n '${q}' | openssl dgst -sha256 -hmac '${sk}'\""
      .!!
      .split(' ')
      .map(_.trim)
  a(1)
</pre>
<pre class="example" id="org02cb610">
import akka.http.scaladsl.model.*

import org.scalatest._
import flatspec._
import matchers._

class PayloadSpec extends AnyFlatSpec with should.Matchers {
  "A signed URI" should "be constructed" in {
    val p =
      "symbol=LTCBTC&amp;side=BUY&amp;type=LIMIT&amp;timeInForce=GTC&amp;quantity=1&amp;price=0.1&amp;recvWindow=5000&amp;timestamp=1499827319559"
    val d =
      "c8db56825ae71d6d79447849e617115f4a920fa2acdcab2b053c4b2838bd6b71"

    import s3.binance.uri
    import s3.payload.withSignature

    val uri1 = uri
      .withRawQueryString(p, Uri.ParsingMode.Strict)
      .withSignature

    uri1.toString should endWith(d)
  }
}
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-03-27 Mon 14:10</p>
</div>
</body>
</html>