<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-08-08 Tue 18:39 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AI writing code</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@300&display=swap" rel="stylesheet">
<style>
font-family: 'Noto Serif', serif;
font-family: 'Noto Sans', sans-serif;
font-family: 'Source Code Pro', monospace;
</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel='stylesheet' type='text/css' href='/css/main.css'/>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">AI writing code</h1>
</header><p>
I am philosophically inclined guy instead of mathematically inclined,
which, at least to me, seems good. I can see things you, people, would
not believe.
</p>

<p>
There is a current hot meme that AI would write code. Well,
theoretically, just like an AI process could learn a suitable
<i>representation</i> for some repeatedly and consistently <i>observed</i> patterns,
it could learn a representation for a function or a whole small
algorithm, using standard optimization procedures and back propagation.
</p>

<p>
Feed it with desired (supervised) inputs and outputs and eventually,
after long enough trials and errors it may come up with a
<i>representation</i> which consists on Abstract syntax trees (not lines of
code) instead of an abstract weighted graph of a certain &ldquo;architecture&rdquo;.
</p>

<p>
There is nothing wrong with this proposal, after all, it is essentially
the same evolutionary process which yields <i>stable intermediate forms</i>
form a particular mixture of basic small molecules, being &ldquo;shacked&rdquo; long
enough.
</p>

<p>
<i>Emerging stable forms</i> is the key principle of almost everything, from
molecular biology and Life Itself, to strange social formations,
including memes.
</p>

<p>
But if we look carefully, all the stable forms seems to be already
emerged long ago, and the smartest guys at early MIT AI lab have noticed
this.
</p>

<p>
There are distinct patterns in molecular biology - linear sequences of
aminoacids with particular emergent electro-chenical properties, which arise out of
certain shapes produced by the spontaneous process of <i>protein folding</i>.
Nevertheless, a linear sequence is the most fundamental pattern or a
form.
</p>

<p>
What we call &ldquo;tree-like structures&rdquo; are another fundamental shape, and
individual synapses are such kind of phisical structures. Notice that
they are &ldquo;<i>directed</i>&rdquo; which means <i>both</i> structurally and as resulting
information flows.
</p>

<p>
<i>Lookup tables</i> are also there, and what we call an <i>enzyme</i>, which is a
molecular <i>machine</i> can be abstracted out as a &ldquo;pure function&rdquo;, or a
mechanical <i>procedure</i> which always produces the same output for the same
sets of inputs.
</p>

<p>
In other words, all thre fundamental stable building blocks are have
been emerged long ago, and smart people in good places have already
captured all the fundamental generalizations and abstracted them out. It
started with idealistic early LISPs and, in another school of thought,
with <i>Lambda Calculus</i>-based pure languages.
</p>

<p>
As you may know, there are only 3 fundamental patterns, out of which
<i>everything</i> can be produced - <i>sequences, branching and loops or
recursion</i>.
</p>

<p>
There are just 3 semantic forms enough for everything - <i>lambda</i>
abstraction, variable <i>binding</i> and <i>application</i>. Lambda, conceptually
at least, corresponds to an enzyme.
</p>

<p>
At a higher, system level, the fundamental principle is <i>coordination</i> based on
<i>asynchronous message passing</i>, and asynchronous is the key. This notion
has been captured and generalized in Erlang.
</p>

<p>
The &ldquo;agents&rdquo; are <i>reactive</i> (never proactive or predictive in principle)
and, again, fundamentally, maintain their own structural &ldquo;information&rdquo;
about how to act triggered by a &ldquo;message&rdquo; or a signal. This
&ldquo;information&rdquo; evolves separately.
</p>

<p>
Simple AI will never be able to &ldquo;learn&rdquo; multi-agent systems. It is a
different level of &ldquo;knowledge&rdquo; and evolution (of an &ldquo;organism&rdquo; or a &ldquo;society&rdquo;).
</p>

<p>
At the highest level of the &ldquo;knowledge&rdquo; how to act is preserved and
&ldquo;evolved&rdquo; in what we call a common, shared culture, and it is mostly in
a symbolically distilled form (capturing semantics of What Is).
</p>

<p>
Will AI discover any new fundamental basic forms? Certainly not. They have
already been discovered by evolution.
</p>

<p>
What then AI will &ldquo;write&rdquo;? Well, there is a good metaphor - the
fundamental cultural difference between  Indian and Japanese cooking.
Indians are basically throwing everything in a pot or a frying pan and
heat it up, while Japanese are trying to carefully select a perfectly matching sets of
ingredients, temperatures, durations and so on.
</p>

<p>
AI will write Indian-style implementations, just like the
representations it currently produces. Change a single node and
everything is completely distorted, which reflects the fact that the
representation is not even remotely optimal. On the contrary it is
sub-optimal and grossly redundant (without the information protecting
property) by definition.
</p>

<p>
The fundamental principle is that AI (a trial-and-error on steroids) is incapable of producing
a complex layered structure due to various fundamental constraints.
</p>

<p>
Essentially, it is due to the fact that a <i>depth-first search process</i>
once gone to a wrong &ldquo;branch&rdquo; will never return, keeping producing <i>vastly
sub-optimal</i> crap, which eventually will &ldquo;work&rdquo;.
</p>

<p>
A process analogous of <i>breadth-first search</i> require <i>more</i> than just feedback and
back-prop. It requires an adequate <i>representation or &ldquo;map&rdquo; of reality</i> - just what
the smartest people extracted from observing molecular biology, evolution
and life itself.
</p>

<p>
No AI is capable of doing extraction of <i>semantic knowledge</i>, similar to
arithmetic or a plane geometry, and without this capacity it will write
utter crap.
</p>

<p>
By the way, it is absolutely astonishing what LISP/ML family of
languages + Erlang has been able to generalize and abstract out. Very few people
understand.
</p>

<p>
So, do not listen to bullshitters, no matter how clever and fluent they
sound. Japanese-style cooking, or <i>proper semantic knowledge</i> will always win.
</p>

<p>
On the other hand, a <i>society</i> of communicating and competing intelligent
agents, each of which maintaining and refining its own representation of
the shared environment, never losing it after malfunction, and, perhaps, <i>broadcasting</i>
parts of it to all other agents, will, at least in theory, come up with
a structural shared &ldquo;knowledge&rdquo;, conceptually similar to Wikipedia, but
at the level of &ldquo;deeper&rdquo; that plain text.
</p>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-08-08 Tue 18:39</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1.50 (<a href="https://orgmode.org">Org</a> mode 9.7-pre)</p>
</div>
</body>
</html>