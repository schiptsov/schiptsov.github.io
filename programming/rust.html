<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-03-09 Thu 10:19 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Rust</h1>
</header>
<div id="outline-container-org81ebe81" class="outline-2">
<h2 id="org81ebe81">Disclaimer</h2>
<div class="outline-text-2" id="text-org81ebe81">
<p>
Even if I rant about <code>Rust</code> a lot, it is only because I <i>do</i> know &ldquo;any better&rdquo; -
Scheme, Common Lisp, SML, Elang, Ocaml, Haskell, Scala3, F#. It is important,
however, to strongly emphasize that <code>Rust</code> is vastly superior and <i>way better designed</i>
language that <code>C++</code>.
</p>

<p>
It is similar in the spirit to what <code>Scheme</code> was back then to all the previous Lisp dialects -
<i>principle-guided</i> reduction to the essence (it was build from the ground up -
from the  Lambda Calculus foundation, like every other decent language) with a
minimal set of required features, and almost everything has been done <i>just
right</i>. <code>Rust</code> is relatively <i>small</i> language, compared to <code>C++</code> or even <code>Scala 3</code> (which
is an <i>principle-guided</i> absolute masterpiece, with careful attention to details,
that Rust lacks).
</p>

<p>
This is just a &ldquo;natural&rdquo; result of the <i>over-enthusiastic</i> but grossly <i>under-qualified</i>
large <i>amateur</i> community, similar to the one which gave us fucking <code>PHP</code> &ldquo;ecosystem&rdquo;.
</p>

<p>
All the wrinkles, however, will eventually go if the core team
will be willing to do tedious work to streamline the concepts with mathematics
and terminology with the SML tradition and unify and refine the syntactic forms in new
&ldquo;editions&rdquo; of the language without being ashamed of <i>borrowing</i> from <code>Scala 3</code> or
<code>Ocaml</code> (better module) or even <code>Erlang</code> (uniform pattern-matching).
</p>

<p>
We can&rsquo;t bury <code>C++</code>, it is already &ldquo;crossed the threshold of immortality&rdquo;, but at
least we could push it to the retirement home, together with <code>Cobol</code> and <code>Java</code>.
</p>
</div>
</div>
<div id="outline-container-org1aba0db" class="outline-2">
<h2 id="org1aba0db">The rant</h2>
<div class="outline-text-2" id="text-org1aba0db">
<p>
I came up with some <i>enlightened</i> and precise definition of <i>why</i> some languages  feel
so crappy, like PHP, which is, as we know, <i>the fractal of bad design</i>.
</p>

<p>
I have been reading a definitive <code>Rust</code> book, full of supposedly idiomatic,
well-chosen examples, and I  regularly cringe <i>intuitively</i> without being able to
articulate exactly why. It just <i>feels</i> crappy at some examples. Now I can articulate <i>why</i>.
</p>

<p>
The language &ldquo;designers&rdquo; and community contributors are <i>math-illiterate</i>. This
and only this. It feels exactly as if some <code>PHP</code> coders are designing a better <code>SML</code> for
systems programming, without understanding <i>why</i>  <code>SML</code> or <code>Ocaml</code> are the way they
are.
</p>

<p>
Here is an example:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #81A1C1;">pub</span> <span style="color: #81A1C1;">fn</span> <span style="color: #88C0D0;">notify</span><span style="color: #81A1C1;">&lt;</span><span style="color: #D8DEE9;">T</span>: <span style="color: #8FBCBB;">Summary</span> + <span style="color: #8FBCBB;">Display</span><span style="color: #81A1C1;">&gt;(</span><span style="color: #D8DEE9;">item</span>: <span style="color: #ECEFF4; background-color: #2E3440;">&amp;</span><span style="color: #8FBCBB;">T</span><span style="color: #81A1C1;">)</span>;
</pre>
</div>
<p>
This is the syntax for constraining an <i>abstract type</i> with multiple &ldquo;trait bounds&rdquo; as they call
it.
</p>

<p>
The operation they are trying to denote is not a <i>Set Union</i> of individual methods, but a
<i>Product</i> of distinct traits (named sets of type-signatures). A <i>star</i> <code>*</code> (for a
<i>product</i>) would be appropriate. The <code>+</code> is mathematically a fundamentally different operation. This particular choice makes one cringe.
</p>

<p>
<code>+</code> is associated with <i>concatenation</i>, so it says a <i>concatenation of methods</i>, while
in fact two distinct <i>Sets</i> of methods are required to be implemented.
</p>

<p>
Even more so is the <code>where</code> clause (<i>borrowed</i> from math or <code>Haskell</code>), which by
itself is the <i>right choice</i>, and then you see that <code>+</code> (a sum) for what is really a <i>product</i>.
</p>

<p>
The math experts who have designed SML have used <code>*</code> for <i>product types</i>.
</p>

<p>
Here, in Rust, this is NOT a product type, but it is a <i>product of two traits</i>. The
precise meaning is a <i>product of two named Sets of type-signatures</i>. Not a <i>sum</i>.
</p>

<p>
Another cringe is that they use <code>push</code> and <code>pop</code> on collections, as if they are
<i>stacks</i>, but this is OK because the idiots were those who designed the <code>C++</code>
collections.
</p>

<p>
There are a few more, mostly in naming of the methods, which I think is an
intention, to make everything look familiar to <code>C++</code> developers,  but my generalization is obviously adequate and correct.
</p>

<p>
<code>Scala</code> feels so much better because the designers came from the right <code>SML</code> tradition,
and are <i>math experts</i>. Odersky is the <i>Giga Chad</i>, you know.
</p>

<p>
Also the lack of a <i>uniform pattern-matching everywhere</i>, like in <code>SML</code>, <code>Ocaml</code> or
<code>F#</code> is a cringe too. As if they just thrown away the most important thing because
they did not get it, again, by being <i>math-illiterate</i>. They could, at least, have
a look at <code>Erlang</code>, which is a <i>high-level system language</i>.
</p>

<p>
By comparing <code>Rust</code> with <code>Scala</code> we could see how and why a <i>principle-guided /attention do
details</i> really matters. <code>Rust</code> feels <i>PHP&rsquo;sque</i>.
</p>

<p>
It is worth knowing that guys at <code>AT&amp;T Bell Labs</code>, who have designed the <i>Basis
library</i> (an <i>stdlib</i>) have explored the possibility of using <code>SML/NJ</code> for system
programming, and there were no problem with the syntax and semantics of the
<code>SML</code>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-03-09 Thu 10:19</p>
</div>
</body>
</html>