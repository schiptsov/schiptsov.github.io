<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-04-13 Thu 14:14 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rust</title>
<meta name="author" content="&lt;schiptsov@gmail.com&gt;" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">

<link href="https://fonts.googleapis.com/css?family=Fira Sans" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Fira Code" rel="stylesheet">

<link rel='stylesheet' type='text/css' href='/css/main.css'/>
<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Rust</h1>
</header>

<div id="outline-container-orgb380a5c" class="outline-2">
<h2 id="orgb380a5c">A meme language, which is OK</h2>
<div class="outline-text-2" id="text-orgb380a5c">
<p>
It has essentially the same <i>social momentum</i> like <code>Perl</code> and then <code>PHP</code> had, except
much larger. Unlike <code>Javascript</code>, it is still a <i>niche</i> language, so more like a
<i>cult</i> to be identified with.
</p>
</div>

<div id="outline-container-org53b2e27" class="outline-3">
<h3 id="org53b2e27">Over-excited amateur community</h3>
<div class="outline-text-3" id="text-org53b2e27">
<p>
One has to be an amateur to be excited about anything. Well, except high quality
art and true craftsmanship in general.
</p>

<p>
It must be noted that the language feels very rough, compared to much refined,
<i>mostly-functional</i> language of the SML family (notably <code>Scala 3</code>), which is the
direct consequence of having a large amateur community.
</p>

<p>
When I say <i>amateur</i> I mean that none of them have been studied programming
languages as a subject and qualified as language designers.
</p>

<p>
It must be admitted that it is way better language than the well known &ldquo;fractal
of bad design&rdquo; (also result of a similar community process), because the team
at Mozilla has at least done alot of (<code>C++</code>) programming beforehand.
</p>
</div>
</div>
<div id="outline-container-orgd4ed239" class="outline-3">
<h3 id="orgd4ed239">Pragmatic</h3>
<div class="outline-text-3" id="text-orgd4ed239">
<p>
Being reasonably high-level, with meaningful high-level syntactic forms (like <code>?</code>)
it is a pragmatic language, indeed.
</p>

<p>
It is a principle-guided <i>imperative</i> language, by <i>restricting</i> what can be done.
</p>

<p>
It is still imperative, so one has <i>Enums</i> instead of proper <i>sum-types</i>.
</p>
</div>
</div>
<div id="outline-container-orgd171844" class="outline-3">
<h3 id="orgd171844">Free community docs</h3>
<div class="outline-text-3" id="text-orgd171844">
<ul class="org-ul">
<li><a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a></li>
<li><a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></li>
<li><a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a></li>
</ul>
</div>
</div>
<div id="outline-container-org1cf0400" class="outline-3">
<h3 id="org1cf0400">Books</h3>
<div class="outline-text-3" id="text-org1cf0400">
<p>
There are a few recent books on some <i>specifics</i>, so all the information is available.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd3bfe90" class="outline-2">
<h2 id="orgd3bfe90">Principles</h2>
<div class="outline-text-2" id="text-orgd3bfe90">
<p>
The mind tends to abstract away (and out) and ignore the details, so should our
<i>high-level</i> languages do.
</p>

<p>
When we have to write down explicitly every single detail we will end up with another Java-like degeneracy.
</p>

<p>
This is may be ok at the implementation side, but it is ridiculous at <i>use site</i>.
So use high-level DSLs or <i>macros</i> to hide all the ugliness.
</p>

<p>
The right thing to do is to have well-crafted <i>defaults</i>, and the clean syntax
(like <code>Scala 3</code>) and allowing to explicitly override any default property
(a universal principle).
</p>
</div>
</div>

<div id="outline-container-org48fb00d" class="outline-2">
<h2 id="org48fb00d">C++</h2>
<div class="outline-text-2" id="text-org48fb00d">
<p>
Programs must be read like arithmetic, not some an_int_implemented_as_with_signals_overflow_in_this_way.static_method_invoked_by_a_constant_reference+(an_instance_of_an_integer_implemented_as&#x2026;.)
</p>

<p>
With all possible symbols thrown in.
</p>
</div>
</div>

<div id="outline-container-org7df3445" class="outline-2">
<h2 id="org7df3445">Ideas</h2>
<div class="outline-text-2" id="text-org7df3445">
<p>
By the way, always having an <i>implicit context</i> (as in Scala) is a universal
notion (not just of a human language, but even animal&rsquo;s stress calls), and it
should be added as a &ldquo;<i>semantic closure</i>&rdquo; &#x2013; a captured <i>meaning</i> (which won&rsquo;t change).
</p>

<p>
Because it is so fundamental, it should have very minimal syntax, like <code>.</code> for accessing the slots.
</p>

<p>
A <i>context</i> is just a frame of an environment, an alist, so we can reuse all the
familiar notions.
</p>

<p>
<i>Semantic</i> environment is not different. We capture meaning (into language) with
<i>properly generalized abstractions</i>.
</p>

<p>
A context is by definition <i>shadowing</i> of symbols (just like a <i>closure</i>).
</p>

<p>
Something like <code>a#b</code> (like in CLU) instead of <code>a.b</code>
</p>
</div>
</div>

<div id="outline-container-orgb950acd" class="outline-2">
<h2 id="orgb950acd">Disclaimer</h2>
<div class="outline-text-2" id="text-orgb950acd">
<p>
Even if I rant about <code>Rust</code> a lot, it is only because I <i>do</i> know &ldquo;any better&rdquo; -
Scheme, Common Lisp, SML, Elang, Ocaml, Haskell, Scala3, F#. It is important,
however, to strongly emphasize that <code>Rust</code> is vastly superior and <i>way better designed</i>
language that <code>C++</code>.
</p>

<p>
It is similar in the spirit to what <code>Scheme</code> was back then to all the previous Lisp dialects -
<i>principle-guided</i> reduction to the essence (it was build from the ground up -
from the  Lambda Calculus foundation, like every other decent language) with a
minimal set of required features, and almost everything has been done <i>just
right</i>. <code>Rust</code> is relatively <i>small</i> language, compared to <code>C++</code> or even <code>Scala 3</code> (which
is an <i>principle-guided</i> absolute masterpiece, with careful attention to details,
that Rust lacks).
</p>

<p>
This is just a &ldquo;natural&rdquo; result of the <i>over-enthusiastic</i> but grossly <i>under-qualified</i>
large <i>amateur</i> community, similar to the one which gave us fucking <code>PHP</code> &ldquo;ecosystem&rdquo;.
</p>

<p>
All the wrinkles, however, will eventually go if the core team
will be willing to do tedious work to streamline the concepts with mathematics
and terminology with the SML tradition and unify and refine the syntactic forms in new
&ldquo;editions&rdquo; of the language without being ashamed of <i>borrowing</i> from <code>Scala 3</code> or
<code>Ocaml</code> (better module) or even <code>Erlang</code> (uniform pattern-matching).
</p>

<p>
We can&rsquo;t bury <code>C++</code>, it is already &ldquo;crossed the threshold of immortality&rdquo;, but at
least we could push it to the retirement home, together with <code>Cobol</code> and <code>Java</code>.
</p>
</div>
</div>
<div id="outline-container-org5720d22" class="outline-2">
<h2 id="org5720d22">The rant</h2>
<div class="outline-text-2" id="text-org5720d22">
<p>
I came up with some <i>enlightened</i> and precise definition of <i>why</i> some languages  feel
so crappy, like PHP, which is, as we know, <i>the fractal of bad design</i>.
</p>

<p>
I have been reading a definitive <code>Rust</code> book, full of supposedly idiomatic,
well-chosen examples, and I  regularly cringe <i>intuitively</i> without being able to
articulate exactly why. It just <i>feels</i> crappy at some examples. Now I can articulate <i>why</i>.
</p>

<p>
The language &ldquo;designers&rdquo; and community contributors are <i>math-illiterate</i>. This
and only this. It feels exactly as if some <code>PHP</code> coders are designing a better <code>SML</code> for
systems programming, without understanding <i>why</i>  <code>SML</code> or <code>Ocaml</code> are the way they
are.
</p>

<p>
Here is an example:
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #81A1C1;">pub</span> <span style="color: #81A1C1;">fn</span> <span style="color: #88C0D0;">notify</span><span style="color: #81A1C1;">&lt;</span><span style="color: #D8DEE9;">T</span>: <span style="color: #8FBCBB;">Summary</span> + <span style="color: #8FBCBB;">Display</span><span style="color: #81A1C1;">&gt;(</span><span style="color: #D8DEE9;">item</span>: <span style="color: #ECEFF4; background-color: #2E3440;">&amp;</span><span style="color: #8FBCBB;">T</span><span style="color: #81A1C1;">)</span>;
</pre>
</div>
<p>
This is the syntax for constraining an <i>abstract type</i> with multiple &ldquo;trait bounds&rdquo; as they call
it.
</p>

<p>
The operation they are trying to denote is not a <i>Set Union</i> of individual methods, but a
<i>Product</i> of distinct traits (named sets of type-signatures). A <i>star</i> <code>*</code> (for a
<i>product</i>) would be appropriate. The <code>+</code> is mathematically a fundamentally different operation. This particular choice makes one cringe.
</p>

<p>
<code>+</code> is associated with <i>concatenation</i>, so it says a <i>concatenation of methods</i>, while
in fact two distinct <i>Sets</i> of methods are required to be implemented.
</p>

<p>
Even more so is the <code>where</code> clause (<i>borrowed</i> from math or <code>Haskell</code>), which by
itself is the <i>right choice</i>, and then you see that <code>+</code> (a sum) for what is really a <i>product</i>.
</p>

<p>
The math experts who have designed SML have used <code>*</code> for <i>product types</i>.
</p>

<p>
Here, in Rust, this is NOT a product type, but it is a <i>product of two traits</i>. The
precise meaning is a <i>product of two named Sets of type-signatures</i>. Not a <i>sum</i>.
</p>

<p>
Another cringe is that they use <code>push</code> and <code>pop</code> on collections, as if they are
<i>stacks</i>, but this is OK because the idiots were those who designed the <code>C++</code>
collections.
</p>

<p>
There are a few more, mostly in naming of the methods, which I think is an
intention, to make everything look familiar to <code>C++</code> developers,  but my generalization is obviously adequate and correct.
</p>

<p>
<code>Scala</code> feels so much better because the designers came from the right <code>SML</code> tradition,
and are <i>math experts</i>. Odersky is the <i>Giga Chad</i>, you know.
</p>

<p>
Also the lack of a <i>uniform pattern-matching everywhere</i>, like in <code>SML</code>, <code>Ocaml</code> or
<code>F#</code> is a cringe too. As if they just thrown away the most important thing because
they did not get it, again, by being <i>math-illiterate</i>. They could, at least, have
a look at <code>Erlang</code>, which is a <i>high-level system language</i>.
</p>

<p>
By comparing <code>Rust</code> with <code>Scala</code> we could see how and why a <i>principle-guided /attention do
details</i> really matters. <code>Rust</code> feels <i>PHP&rsquo;sque</i>.
</p>

<p>
It is worth knowing that guys at <code>AT&amp;T Bell Labs</code>, who have designed the <i>Basis
library</i> (an <i>stdlib</i>) have explored the possibility of using <code>SML/NJ</code> for system
programming, and there were no problem with the syntax and semantics of the
<code>SML</code>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: &lt;schiptsov@gmail.com&gt;</p>
<p class="email">Email: <a href="mailto:lngnmn2@yahoo.com">lngnmn2@yahoo.com</a></p>
<p class="date">Created: 2023-04-13 Thu 14:14</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.0.90 (<a href="https://orgmode.org">Org</a> mode 9.6.1)</p>
</div>
</body>
</html>